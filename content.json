{"meta":{"title":"小金渣blog","subtitle":null,"description":null,"author":"小金渣","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"打卡第一天_2019.04.29","slug":"打卡第一天-2019-04-29","date":"2019-04-29T14:26:31.000Z","updated":"2019-04-29T14:27:08.083Z","comments":true,"path":"2019/04/29/打卡第一天-2019-04-29/","link":"","permalink":"http://yoursite.com/2019/04/29/打卡第一天-2019-04-29/","excerpt":"","text":"打卡第一天_2019.04.29 英语单词20个 面试题一：说下线程与进程的区别和练习？ 面试图二：怎么用 copy 关键字？ 答案一： 一个程序至少要有进程,一个进程至少要有一个线程。 进程：资源分配的最小独立单元,进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。 线程:进程下的一个分支,是进程的实体,是CPU调度和分派的基本单元,它是比进程更小的能独立运行的基本单位,线程自己基本不拥有系统资源,只拥有一点在运行中必不可少的资源(程序计数器、一组寄存器、栈)，但是它可与同属一个进程的其他线程共享进程所拥有的全部资源。 进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 答案二： copy 的语义是将对象拷贝一份给新的引用，通过新的引用对它的修改不影响原来那个被拷贝的对象。 NSString、NSArray、NSDictionary 等等经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary。 block 也经常使用 copy 关键字。block 使用 copy 是从 MRC 遗留下来的传统，在 MRC 中，方法内部的 block 是在栈区的，使用 copy 可以把它放到堆区。在 ARC 中写不写都行，对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。","categories":[{"name":"Flag","slug":"Flag","permalink":"http://yoursite.com/categories/Flag/"}],"tags":[{"name":"Flag","slug":"Flag","permalink":"http://yoursite.com/tags/Flag/"}],"keywords":[{"name":"Flag","slug":"Flag","permalink":"http://yoursite.com/categories/Flag/"}]},{"title":"Flag立起来","slug":"Flag立起来","date":"2019-04-28T16:08:02.000Z","updated":"2019-04-29T00:23:20.777Z","comments":true,"path":"2019/04/29/Flag立起来/","link":"","permalink":"http://yoursite.com/2019/04/29/Flag立起来/","excerpt":"","text":"Flag立个flag： 1.每天吃透2道面试题； 2.每天熟记20个英语单词。 2019.04.29","categories":[{"name":"Flag","slug":"Flag","permalink":"http://yoursite.com/categories/Flag/"}],"tags":[{"name":"Flag","slug":"Flag","permalink":"http://yoursite.com/tags/Flag/"}],"keywords":[{"name":"Flag","slug":"Flag","permalink":"http://yoursite.com/categories/Flag/"}]},{"title":"Swift基础—集合类型","slug":"Swift基础—集合类型","date":"2019-04-26T14:07:06.000Z","updated":"2019-04-29T02:29:36.030Z","comments":true,"path":"2019/04/26/Swift基础—集合类型/","link":"","permalink":"http://yoursite.com/2019/04/26/Swift基础—集合类型/","excerpt":"","text":"##1.数组## 声明一个不可修改的数组12let num1 = [1,2,3]let num2 = [Int](repeating: 0, count: 5) 声明一个可以修改的数组 1var num3 = [3,1,2] 增加一个元素 1num3.append(4) 对原数组进行升序排序 1num3.sort() 对原数组进行降序排序 1num3.sort(by:&gt;) 将原数组除最后一个外的所有元素赋值给另一个数组 1let num4 = Array(num3[0..&lt;num3.count - 1]) 用数组实现栈123456789101112131415161718192021class Stack&#123;var stack: [AnyObject]var isEmpty: Bool&#123; return stack.isEmpty &#125;var peek: AnyObject? &#123; return stack.last &#125;init() &#123;stack = [AnyObject]()&#125;func push(object: AnyObject)&#123;stack.append(object)&#125;func pop() -&gt; AnyObject? &#123;if (!isEmpty) &#123;return stack.removeLast()&#125;else&#123;return nil &#125; &#125;&#125; ##字典和集合##12var primeNums: Set = [3, 5,7,11, 13]let oddNums: Set = [1, 3, 5, 7, 9] 交集、并集、差集 123let primeAndOddNum = primeNums.intersection(oddNums)let primeOrOddNum = primeNums.union(oddNums)let oddNumNotPrime = oddNums.subtracting(primeNums) 题目：给出一个整数型数组和一个目标值，判断数组中是否有两个数之和等于目标值。 123456789101112func twoSum(nums: [Int], _ target: Int) -&gt;Bool&#123;var set = Set&lt;Int&gt;()for num in nums &#123;if set.contains(target - num) &#123;return true &#125;set.insert(num) &#125;return false&#125; 题目改成：给定一个整数型数组中有且仅有两个数之和等于目标值，求这两个数在数组中的序号。 1234567891011121314func twoSum(nums: [Int], _ target:[Int] -&gt; [Int])&#123;var dict = [Int : Int]()for (i, num) in nums.enumerated() &#123;if let lastIndex = dict[target - num] &#123;return [lastIndex, i]&#125;else&#123;dict[num] = i &#125;&#125;fatalError(&quot;No valid output!&quot;)&#125; ##字符串##在Swift中，字符串不同于其他语言(包括OC),它是值类型，而非引用类型。 字符串和数字之间的转换 1234let str = &quot;3&quot;let num = Int(str)let number = 3let string = String(num) 字符串长度 1let len = str.count 访问字符串中的单个字符，时间复杂度为0（1） 1let char = str[str.index(str.startIndex, offsetBy: n)] 修改字符串 123str.remove(at: n)str.append(&quot;c&quot;)str += &quot;hello world&quot; 检测字符串是否由数字构成 123func isStrNum(str: String) -&gt; Bool&#123;return Int(str) != nil&#125; 将字符串数字按字母排序(不考虑大小写) 123func sortStr(str: String) -&gt; String&#123;return String(str.sorted())&#125; Google面试题：给出一个字符串，要求将其按照单词顺序进行反转。比如“the sky is blue”,反转后的结果是“blue is sky the”。思路：1.每个单词长度不一样；2.每个单词长度不一样。3.先实现一个字符串反转的方法 123456789101112fileprivate func _reverse&lt;T&gt;(_chars: inout [T], _ start: Int, _ end: Int)&#123;var start = start, end = endwhile start &lt; end &#123;_swap(&amp;chars, start, end)start += 1end -= 1 &#125;&#125;fileprivate func swap&lt;T&gt;(_ chars: inout [T], _ p: Int, _ q: Int)&#123;(chars[p], chars[q], chars[p])&#125; 有了这个方法，就可以实现下面两种字符串的转换：1.整个字符串反转，“the sky is blue” -&gt; “eulb si yks eht”;2.每个单词作为一个字符串单独反转，“eulb si yks eht” -&gt; “blue is sky the”。 12345678910111213141516func reverseWords(s: String?) -&gt; String?&#123;guard let s = s else&#123;return nil&#125;var chars = Array(s.characters), start = 0_reverse(&amp;chars: 0, chars.count - 1)for i in 0..chars.count &#123;if i == chars.count - 1 || chars[i + 1] = &quot;&quot; &#123;_reverse(&amp;chars .start, i)start = i + 2 &#125; &#125;return String(chars)&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}]},{"title":"启动速度怎么做优化与监控","slug":"启动速度怎么做优化与监控","date":"2019-04-20T13:33:52.000Z","updated":"2019-04-29T13:34:46.333Z","comments":true,"path":"2019/04/20/启动速度怎么做优化与监控/","link":"","permalink":"http://yoursite.com/2019/04/20/启动速度怎么做优化与监控/","excerpt":"","text":"APP启动一般情况下，App 的启动分为冷启动和热启动。 冷启动： App 点击启动前，它的进程不在系统里，需要系统新创建一个进程分配给它启动的情况。这是一次完整的启动过程。 热启动：App 在冷启动后用户将 App 退后台，在 App 的进程还在系统里的情况下，用户重新启动进入 App 的过程，这个过程做的事情非常少。 App 的启动主要包括三个阶段 1.main()函数执行前 2.main()函数执行后 3.首屏渲染完成后main()函数执行前 加载可执行文件（App 的.o 文件的集合）； 加载动态链接库，进行 rebase 指针调整和 bind 符号绑定； Objc 运行时的初始处理，包括 Objc 相关类的注册、category 注册、selector 唯一性检查等； 初始化，包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量。 相应地，这个阶段对于启动速度优化来说，可以做的事情包括： 减少动态库加载。每个库本身都有依赖关系，苹果公司建议使用更少的动态库，并且建议在使用动态库的数量较多时，尽量将多个动态库进行合并。数量上，苹果公司最多可以支持 6 个非系统动态库合并为一个。 减少加载启动后不会去使用的类或者方法。 +load() 方法里的内容可以放到首屏渲染完成后再执行，或使用 +initialize() 方法替换掉。因为，在一个 +load() 方法里，进行运行时方法替换操作会带来 4 毫秒的消耗。不要小看这 4 毫秒，积少成多，执行 +load() 方法对启动速度的影响会越来越大。 控制 C++ 全局变量的数量。 main()函数执行后main() 函数执行后的阶段，指的是从 main() 函数执行开始，到 appDelegate 的 didFinishLaunchingWithOptions 方法里首屏渲染相关方法执行完成。 首页的业务代码都是要在这个阶段，也就是首屏渲染前执行的，主要包括了： 首屏初始化所需配置文件的读写操作； 首屏列表大数据的读取； 首屏渲染的大量计算等。 很多时候，开发者会把各种初始化工作都放到这个阶段执行，导致渲染完成滞后。更加优化的开发方式，应该是从功能上梳理出哪些是首屏渲染必要的初始化功能，哪些是 App 启动必要的初始化功能，而哪些是只需要在对应功能开始使用时才需要初始化的。梳理完之后，将这些初始化功能分别放到合适的阶段进行。 smain()首屏渲染完成后首屏渲染后的这个阶段，主要完成的是，非首屏其他业务服务模块的初始化、监听的注册、配置文件的读取等。从函数上来看，这个阶段指的就是截止到 didFinishLaunchingWithOptions 方法作用域内执行首屏渲染之后的所有方法执行完成。简单说的话，这个阶段就是从渲染完成时开始，到 didFinishLaunchingWithOptions 方法作用域结束时结束。 这个阶段用户已经能够看到 App 的首页信息了，所以优化的优先级排在最后。但是，那些会卡住主线程的方法还是需要最优先处理的，不然还是会影响到用户后面的交互操作。 明白了 App 启动阶段需要完成的工作后，我们就可以有的放矢地进行启动速度的优化了。这些优化，包括了功能级别和方法级别的启动优化。接下来，我们就从这两个角度展开看看。 功能级别的启动优化功能级别的启动优化，就是要从 main() 函数执行后这个阶段下手。 优化的思路是： main() 函数开始执行后到首屏渲染完成前只处理首屏相关的业务，其他非首屏业务的初始化、监听注册、配置文件读取等都放到首屏渲染完成后去做。如下图所示： 方法级别的启动优化经过功能级别的启动优化，我们需要进一步做的，是检查首屏渲染完成前主线程上有哪些耗时方法，将没必要的耗时方法滞后或者异步执行。通常情况下，耗时较长的方法主要发生在计算大量数据的情况下，具体的表现就是加载、编辑、存储图片和文件等资源。 但不是只需要优化对资源的操作就可以了。 目前对App 启动速度的监控，主要有两种手段。 第一种方法是，定时抓取主线程上的方法调用堆栈，计算一段时间里各个方法的耗时。 Xcode 工具套件里自带的 Time Profiler ，采用的就是这种方式。 这种方式的优点是，开发类似工具成本不高，能够快速开发后集成到你的 App 中，以便在真实环境中进行检查。 说到定时抓取，就会涉及到定时间隔的长短问题。 定时间隔设置得长了，会漏掉一些方法，从而导致检查出来的耗时不精确；而定时间隔设置得短了，抓取堆栈这个方法本身调用过多也会影响整体耗时，导致结果不准确。这个定时间隔如果小于所有方法执行的时间（比如 0.002 秒），那么基本就能监控到所有方法。但这样做的话，整体的耗时时间就不够准确。一般将这个定时间隔设置为 0.01 秒。这样设置，对整体耗时的影响小，不过很多方法耗时就不精确了。但因为整体耗时的数据更加重要些，单个方法耗时精度不高也是可以接受的，所以这个设置也是没问题的。 总结来说，定时抓取主线程调用栈的方式虽然精准度不够高，但也是够用的。 第二种方法是，对 objc_msgSend 方法进行 hook 来掌握所有方法的执行耗时。 hook 方法的意思是，在原方法开始执行时换成执行其他你指定的方法，或者在原有方法执行前后执行你指定的方法，来达到掌握和改变指定方法的目的。 hook objc_msgSend 这种方式的优点是非常精确，而缺点是只能针对 Objective-C 的方法。当然，对于 c 方法和 block 也不是没有办法，你可以使用 libffi 的 ffi_call 来达成 hook，但缺点就是编写维护相关工具门槛高。 综上，如果对于检查结果精准度要求高的话，推荐使用 hook objc_msgSend 方式来检查启动方法的执行耗时。","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"APP","slug":"APP","permalink":"http://yoursite.com/tags/APP/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"}],"keywords":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}]},{"title":"iOS开发体系","slug":"iOS开发体系","date":"2019-04-02T11:35:28.000Z","updated":"2019-04-26T12:36:37.346Z","comments":true,"path":"2019/04/02/iOS开发体系/","link":"","permalink":"http://yoursite.com/2019/04/02/iOS开发体系/","excerpt":"","text":"####iOS开发体系 iOS 的知识体系，包括了基础、原理、应用开发、原生与前端四大模块。#####基础模块iOS 开发者需要掌握的整个基础知识，按照 App 的开发流程进行了划分，如下图所示。#####应用开发应用开发部分，需要关注一些经典的库。#####原理模块iOS开发原理，主要是系统内核 XNU、AOP、内存管理和编译的知识。这些知识具有很强的通用性，其他任何语言、系统和领域都会涉及到。#####原生与前端原生和前端部分，需要分析隐藏在这些技术背后的解释器和渲染技术，也正是这些技术造就了目前跨端方案的繁荣。从 H5 到 Flutter，渲染底层图形库都使用的是 Skia。也就是说，这么多年来渲染底层技术就基本没有变过。而且，向 Flutter 的演进也只是去掉了 H5 对低版本标准的支持。但，仅仅是去掉这些兼容代码，就使性能提升了数倍。 #####iOS知识体系整个专栏中涉及到的基础、原理、应用开发和原生与前端的知识，梳理到一起，就形成了如下图所示的 iOS 知识体系。","categories":[{"name":"进阶","slug":"进阶","permalink":"http://yoursite.com/categories/进阶/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}],"keywords":[{"name":"进阶","slug":"进阶","permalink":"http://yoursite.com/categories/进阶/"}]},{"title":"iOS-多线程","slug":"iOS-多线程","date":"2019-02-18T14:03:07.000Z","updated":"2019-04-29T02:34:30.363Z","comments":true,"path":"2019/02/18/iOS-多线程/","link":"","permalink":"http://yoursite.com/2019/02/18/iOS-多线程/","excerpt":"","text":"###进程### 进程是指在系统中运行的一个程序 ###线程### 1个进程要想执行任务必须得有线程(每个进程至少要有1条线程) ###线程的串行### 一个线程中任务的执行时串行的,如果要在1个线程中执行多个任务,那么只能一个一个地按顺序执行这些任务.也就是说,在同一时间内,1个线程只能执行1个任务 ###进程和线程的比较### 1.线程是CPU调用(执行任务)的最小单位 2.进程是CPU分配资源和调度的单位 3.一个程序可以对应多个线程,一个进程中可以有多个线程,但至少要有一个线程 4.同一个进程内的线程共享进程的资源 ###多线程### 1个进程中可以开启多个线程每条线程可以并行(同时)执行不同的任务,多线程技术可以提高程序的执行效率 ###多线程原理### 同一时间,CPU只能处理1条线程,只有1条线程在工作(执行) 多线程并发(同时)执行,其实CPU快速地在多条线程之间调度(切换) 如果CPU调度线程的时间足够快,就造成了多线程并发执行的假象 注:单核CPU ###多线程优缺点### #####优点:##### 能适当提高程序的执行效率 能适当提高资源利用(CPU 内存利用率) #####缺点:##### 创建线程是有开销的,iOS下主要成本包括:内核数据结构(大约1KB),栈控件(子线程512KB,主线程1M,也可以使用-setStackSize:设置,但必须是4K的倍数,而且最小是16K),创建线程大约需要90毫秒的创建时间 如果开启大量的线程,会降低程序的性能 线程越多,CPU在调度线程上的开销就越大 程序设计更加复杂:比如线程之间的通信,多线程的数据共享 ###主线程### 一个iOS程序运行后,默认会开启1条线程,称为”主线程”或”UI线程” ###主线程的主要作用:### 1.显示\\刷新UI界面 2.处理UI事件(比如点击事件,滚动事件,拖拽事件等) ###主线程的使用注意:### 1.别将比较耗时的操作放到主线程(文件上传下载,多次循环) 2.耗时操作会卡主主线程,严重影响到UI的流畅度,给用户一种”卡”的怀体验 ###获取主线程、当前线程###12345678910111213141516//1.获取主线程NSThread *mainThread = [NSThread mainThread];NSLog(@&quot;%@&quot;,mainThread);//2.获取当前线程NSThread *currentThread = [NSThread currentThread];NSLog(@&quot;%@&quot;,currentThread);//3.判断主线程// 3.1 number == 1// 3.2 类方法BOOL isMainThreadA = [NSThread mainThread];// 3.3 对象方法BOOL isMainThreadB = [currentThread isMainThread];NSLog(@&quot;%zd----%zd&quot;,isMainThreadA,isMainThreadB); ##1.Pthread的简单使用（了解）##pthread是一套通用的多线程API适用于Unix、Linux、Windows等系统跨平台、可移植、使用难度大C语言、需要手动管理线程生命周期1234567891011121314151617181920- (void)viewDidLoad &#123;[super viewDidLoad];//1.创建线程对象pthread_t thread;//2.创建线程/*第一个参数:线程对象 传递地址第二个参数:线程的属性 NULL第三个参数:指向函数的指针第四个参数:函数需要接受的参数*/pthread_create(&amp;thread, NULL, task, NULL);&#125;void *task(void *param)&#123;NSLog(@&quot;%@-----&quot;,[NSThread currentThread]);return NULL;&#125; ##2.NSthread的基本使用##NSthread使用更加面向对象简单易用，可直接操作线程对象OC语言、需要手动管理线程生命周期 ####NSThread创建的第一种方法####需要手动启用线程1234567891011121314151617181920- (void)viewDidLoad &#123;[super viewDidLoad];//1.创建线程/*第一个参数:目标对象,self第二个参数:方法选择器,调用方法第三个参数:前面调用方法需要传递的参数 nil*/NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run:) object:@&quot;ABC&quot;];//2.启动线程[thread start];&#125;-(void)run:(NSString *)param&#123;NSLog(@&quot;----RUN----%@&quot;,[NSThread currentThread]);&#125; #####NSThread创建的第二种方法#####分离子线程，自动启动线程1234567891011- (void)viewDidLoad &#123;[super viewDidLoad];[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;分离子线程&quot;];&#125;-(void)run:(NSString *)param&#123;NSLog(@&quot;----RUN----%@&quot;,[NSThread currentThread]);&#125; #####NSThread创建的第三种方法#####开启一条后台线程1234567891011- (void)viewDidLoad &#123;[super viewDidLoad];[self performSelectorInBackground:@selector(run:) withObject:@&quot;开启后台线程&quot;];&#125;-(void)run:(NSString *)param&#123;NSLog(@&quot;----RUN----%@&quot;,[NSThread currentThread]);&#125; #####第二、三种方法的优缺点：#####优点：简单快捷缺点：无法对线程进行更详细的设置 #####NSThread需要注意的属性方法#####123456789//设置线程名称@property (nullable, copy) NSString *name //设置线程优先级+ (double)threadPriority;//获得主线程+（NSThread *)mainThread;//是否为主线程-（BOOL）isMainThread; #####NSThread线程生命周期#####线程的生命周期：当任务执行完毕后被释放 #####NSThread线程状态(了解)#####12NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];[thread start]; 启动线程12- (void)start; // 进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态 阻塞（暂停）线程123+ (void)sleepUntilDate:(NSDate *)date;+ (void)sleepForTimeInterval:(NSTimeInterval)ti;// 进入阻塞状态 强制停止线程12+ (void)exit;// 进入死亡状态 注意：一旦线程停止（死亡）了，就不能再次开启任务 #####多线程的安全隐患#####以售票员买票为例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import &quot;ViewController.h&quot;@interface ViewController ()//售票员 A B C@property (nonatomic,strong) NSThread *threadA;@property (nonatomic,strong) NSThread *threadB;@property (nonatomic,strong) NSThread *threadC;//总票数@property (nonatomic,assign) NSInteger totalCount;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];self.totalCount = 100;self.threadA = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicket) object:nil];self.threadB = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicket) object:nil];self.threadC = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicket) object:nil];self.threadA.name = @&quot;售票员1&quot;;self.threadB.name = @&quot;售票员1&quot;;self.threadC.name = @&quot;售票员1&quot;;[self.threadA start];[self.threadB start];[self.threadC start];&#125;-(void)saleTicket&#123;while (1) &#123;//锁必须是全局唯一的//1.注意加锁的位置//2.注意枷锁的前提条件//3.注意枷锁是需要代价的,需要耗费性能//4.枷锁的结果:线程同步@synchronized(self)&#123;NSInteger count = self.totalCount;if (count &gt; 0) &#123;self.totalCount = count - 1;//卖出一张票NSLog(@&quot;%@卖出一张票,还剩%zd张票&quot;,[NSThread currentThread].name,self.totalCount);&#125;else&#123;NSLog(@&quot;票已售完,明天请早!&quot;);break; &#125; &#125; &#125;&#125;@end 互斥锁使用格式@synchronized(锁对象) { // 需要锁定的代码 }注意：锁定1份代码只用1把锁，用多把锁是无效的 互斥锁的优缺点优点：能有效防止因多线程抢夺资源造成的数据安全问题缺点：需要消耗大量的CPU资源 互斥锁的使用前提：多条线程抢夺同一块资源 相关专业术语：线程同步线程同步的意思是：多条线程在同一条线上执行（按顺序地执行任务）互斥锁，就是使用了线程同步技术 #####原子和非原子属性的选择nonatomic和atomic对比atomic：线程安全，需要消耗大量的资源nonatomic：非线程安全，适合内存小的移动设备 iOS开发的建议所有属性都声明为nonatomic尽量避免多线程抢夺同一块资源尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力 #####NSThread实现线程间通信#####什么叫做线程间通信？ 在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常- 进行通信 线程间通信的体现 1个线程传递数据给另1个线程 在1个线程中执行完特定任务后，转到另1个线程继续执行任务 线程间通信常用方法123- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait; 线程间通信示例 – 图片下载1234567891011121314151617181920212223242526272829-(void)touchesBegan:(nonnull NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event&#123;// [self download2];//开启一条子线程来下载图片[NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];&#125;-(void)downloadImage&#123;//1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源NSURL *url = [NSURL URLWithString:@&quot;http://p6.qhimg.com/t01d2954e2799c461ab.jpg&quot;];//2.根据url地址下载图片数据到本地（二进制数据NSData *data = [NSData dataWithContentsOfURL:url];//3.把下载到本地的二进制数据转换成图片UIImage *image = [UIImage imageWithData:data];//4.回到主线程刷新UI//4.1 第一种方式// [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES];//4.2 第二种方式// [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES];//4.3 第三种方式[self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES];&#125; 如何计算代码段的执行时间12345678910111213//第一种方法NSDate *start = [NSDate date];//2.根据url地址下载图片数据到本地（二进制数据）NSData *data = [NSData dataWithContentsOfURL:url];NSDate *end = [NSDate date];NSLog(@&quot;第二步操作花费的时间为%f&quot;,[end timeIntervalSinceDate:start]);//第二种方法CFTimeInterval start = CFAbsoluteTimeGetCurrent();NSData *data = [NSData dataWithContentsOfURL:url];CFTimeInterval end = CFAbsoluteTimeGetCurrent();NSLog(@&quot;第二步操作花费的时间为%f&quot;,end - start); ###3.GCD的使用###什么是GCD? 全称是Grand Central Dispatch，可译为“牛逼的中枢调度器” 纯C语言，提供了非常多强大的函数 GCD的优势 GCD是苹果公司为多核的并行运算提出的解决方案 GCD会自动利用更多的CPU内核（比如双核、四核） GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程） 程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码 GCD中有2个核心概念 任务：执行什么操作 队列：用来存放任务 GCD的使用就2个步骤 定制任务确定想做的事情 将任务添加到队列中GCD会自动将队列中的任务取出，放到对应的线程中执行任务的取出遵循队列的FIFO原则：先进先出，后进后出 #####执行任务##### ######GCD中有2个用来执行任务的常用函数1.用同步的方式执行任务123dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);queue：队列block：任务 2.用异步的方式执行任务1dispatch_async(dispatch_queue_t queue, dispatch_block_t block); 同步和异步的区别 同步：只能在当前线程中执行任务，不具备开启新线程的能力 异步：可以在新的线程中执行任务，具备开启新线程的能力 GCD中还有个用来执行任务的函数（栅栏函数)：1dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block); 在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行- 这个queue不能是全局的并发队列 #####队列的类型##### ######GCD的队列可以分为2大类型###### 并发队列（Concurrent Dispatch Queue）可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）并发功能只有在异步（dispatch_async）函数下才有效 串行队列（Serial Dispatch Queue）让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务） #####容易混淆的术语#####有4个术语比较容易混淆：_同步_、_异步_、_并发_、_串行_同步和异步主要影响：能不能开启新的线程同步：只是在_当前_线程中执行任务，不具备开启新线程的能力异步：可以在_新的_线程中执行任务，_具备_开启新线程的能力 并发和串行主要影响：任务的执行方式并发：允许_多个_任务并发（同时）执行_串行_：_一个_任务执行完毕后，再执行下一个任务 #####并发队列##### 使用dispatch_queue_create函数创建队列 123dispatch_queue_tdispatch_queue_create(const char *label, // 队列名称 dispatch_queue_attr_t attr); // 队列的类型 创建并发队列 1dispatch_queue_t queue = dispatch_queue_create(&quot;com.520it.queue&quot;, DISPATCH_QUEUE_CONCURRENT); GCD默认已经提供了全局的并发队列，供整个应用使用，可以无需手动创建使用dispatch_get_global_queue函数获得全局的并发队列 123dispatch_queue_t dispatch_get_global_queue(dispatch_queue_priority_t priority, // 队列的优先级unsigned long flags); // 此参数暂时无用，用0即可 获得全局并发队列 1dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 全局并发队列的优先级 1234#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台 #####串行队列##### GCD中获得串行有2种途径使用dispatch_queue_create函数创建串行队列12// 创建串行队列（队列类型传递NULL或者DISPATCH_QUEUE_SERIAL）dispatch_queue_t queue = dispatch_queue_create(&quot;com.520it.queue&quot;, NULL); 使用主队列（跟主线程相关联的队列）1.主队列是GCD自带的一种特殊的串行队列2.放在主队列中的任务，都会放到主线程中执行3.使用dispatch_get_main_queue()获得主队列1dispatch_queue_t queue = dispatch_get_main_queue(); #####各种队列的执行效果##### #####GCD线程间通信##### 从子线程回到主线程1234567dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;// 执行耗时的异步操作...dispatch_async(dispatch_get_main_queue(), ^&#123;// 回到主线程，执行UI刷新操作&#125;);&#125;); #####延时执行#####iOS常见的延时执行 1.调用NSObject的方法 12[self performSelector:@selector(run) withObject:nil afterDelay:2.0];// 2秒后再调用self的run方法 2.使用GCD函数 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;// 2秒后执行这里的代码...&#125;); 3.使用NSTimer 1[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:NO]; #####一次性代码##### 使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次 不可以放在懒加载中执行1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;// 只执行1次的代码(这里面默认是线程安全的)&#125;); #####快速迭代##### 使用dispatch_apply函数能进行快速迭代遍历123456//第一个参数：遍历的次数//第二个参数：队列(并发队列)，不可以传主队列会造成死锁；不可以传串行队列，没有任何作用//第三个参数：index 索引dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t index)&#123;// 执行10次代码，index顺序不确定&#125;); #####队列组##### 有这么1种需求1.分别异步执行2个耗时的操作2.等2个异步操作都执行完毕后，再回到主线程执行操作 如果想要快速高效地实现上述需求，可以考虑用队列组1234567891011121314dispatch_group_t group = dispatch_group_create();//1.封装任务//2.把任务添加到队列中//3.会监听任务的执行情况，通知groupdispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;// 执行1个耗时的异步操作&#125;);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;// 执行1个耗时的异步操作&#125;);//拦截通知，当队列组中所有的任务都执行完毕的时候会进入到下面的方法dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;// 等前面的异步操作都执行完毕后，回到主线程...&#125;); ###3.NSOperation的使用### NSOperation的作用配合使用NSOperation和NSOperationQueue也能实现多线程编程 NSOperation和NSOperationQueue实现多线程的具体步骤1.先将需要执行的操作封装到一个NSOperation对象中2.然后将NSOperation对象添加到NSOperationQueue中3.系统会自动将NSOperationQueue中的NSOperation取出来4.将取出的NSOperation封装的操作放到一条新线程中执行 #####NSOperation的子类##### NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类 使用NSOperation子类的方式有3种1.NSInvocationOperation2.NSBlockOperation3.自定义子类继承NSOperation，实现内部相应的方法 #####NSInvocationOperation##### 创建NSInvocationOperation对象 12345- (id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;调用start方法开始执行操作- (void)start;一旦执行操作，就会调用target的sel方法 注意1.默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作2.只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作 #####NSBlockOperation##### 创建NSBlockOperation对象 1+ (id)blockOperationWithBlock:(void (^)(void))block; 通过addExecutionBlock:方法添加更多的操作 1- (void)addExecutionBlock:(void (^)(void))block; 注意：只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作 #####NSOperationQueue NSOperationQueue的作用1.NSOperation可以调用start方法来执行任务，但默认是同步执行的2.如果将NSOperation添加到NSOperationQueue（操作队列）中，系统会自动异步执行NSOperation中的操作 添加操作到NSOperationQueue中 12- (void)addOperation:(NSOperation *)op;- (void)addOperationWithBlock:(void (^)(void))block; #####自定义NSOperation##### 自定义NSOperation的步骤很简单重写- (void)main方法，在里面实现想执行的任务 重写- (void)main方法的注意点自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）经常通过- (BOOL)isCancelled方法检测操作是否被取消，对取消做出响应 #####最大并发数##### 什么是并发数同时执行的任务数比如，同时开3个线程执行3个任务，并发数就是3 最大并发数的相关方法 12345678- (NSInteger)maxConcurrentOperationCount;- (void)setMaxConcurrentOperationCount:(NSInteger)cnt;//串行执行任务不等于只开一条线程(编程同步)maxConcurrentOperationCount &gt; 1 并发队列maxConcurrentOperationCount == 1 串行队列maxConcurrentOperationCount == 0 不会执行任务maxConcurrentOperationCount == -1 特殊意义 最大值 表示不受限制 #####队列的取消、暂停、恢复 取消队列的所有操作 123//取消不可以恢复- (void)cancelAllOperations;//提示：也可以调用NSOperation的- (void)cancel方法取消单个操作 暂停和恢复队列 1234//暂停是可以恢复//不能暂停当前正在处于执行状态的任务- (void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列- (BOOL)isSuspended; #####操作依赖 NSOperation之间可以设置依赖来保证执行顺序比如一定要让操作A执行完后，才能执行操作B，可以这么写 1[operationB addDependency:operationA]; // 操作B依赖于操作A 可以在不同queue的NSOperation之间创建依赖关系 #####操作的监听 可以监听一个操作的执行完毕12- (void (^)(void))completionBlock;- (void)setCompletionBlock:(void (^)(void))block; #####NSOperation实现线程间通信12345678910111213141516171819202122232425262728-(void)download&#123;//http://s15.sinaimg.cn/bmiddle/4c0b78455061c1b7f1d0e//1.开子线程下载图片//1.1 非主队列NSOperationQueue *queue = [[NSOperationQueue alloc]init];//1.2 封装操作NSBlockOperation *download = [NSBlockOperation blockOperationWithBlock:^&#123;NSURL *url = [NSURL URLWithString:@&quot;http://s15.sinaimg.cn/bmiddle/4c0b78455061c1b7f1d0e&quot;];NSData *imageData = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:imageData];NSLog(@&quot;download---%@&quot;,[NSThread currentThread]);//3.回到主线程、更新UI[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;self.imageView.image = image;NSLog(@&quot;UI---%@&quot;,[NSThread currentThread]);&#125;];&#125;];//2.添加操作到队列[queue addOperation:download];&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}],"keywords":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}]},{"title":"iOS-Block","slug":"iOS-Block","date":"2019-01-26T12:17:13.000Z","updated":"2019-04-26T12:28:26.872Z","comments":true,"path":"2019/01/26/iOS-Block/","link":"","permalink":"http://yoursite.com/2019/01/26/iOS-Block/","excerpt":"","text":"###1.block概述 Block是一种特殊的数据类型,其可以正常定义变量、作为参数、作为返回值,特殊地,Block还可以保存一段代码,在需要的时候调用,目前Block已经广泛应用于iOS开发中,常用于GCD、动画、排序及各类回调。 ###2.block作用 保存一段代码 ###3.block声明12//block声明: 返回值(^block变量名)(参数)void(^block)(); ###4.block定义12345678910111213141516//block定义:3种方式 ==&gt; ^(参数)&#123;&#125;//1.void(^block1)() = ^()&#123;&#125;;//2.如果没有参数,参数可以隐藏. 如果有参数,定义的时候必须写参数,而且必须要有参数变量名void(^block2)(int) = ^(int a)&#123;&#125;;//3.block返回可以省略,不管有没有返回值都可以省略int(^block3)() = ^int&#123;return 3;&#125;; ###5.block类型NSGlobalBlock （NSConcreteGlobalBlock）NSStackBlock （NSConcreteStackBlock）NSMallocBlock （__NSConcreteMallocBlock） 1.NSGlobalBlock12345void(^block)(void) = ^(void) &#123; &#125;;block();NSLog(@&quot;%@&quot;,block); 控制台打印： 2018-08-04 13:49:15.074751+0800 Block[32487:7895146] &lt;NSGlobalBlock: 0x1071e8088&gt; 2.NSMallocBlock123456int a = 10;void(^block)(void) = ^(void) &#123;NSLog(@&quot;%d&quot;,a);&#125;;block();NSLog(@&quot;%@&quot;,block); 控制台打印： 2018-08-04 13:53:49.489064+0800 Block[32567:7900709] 102018-08-04 13:53:49.489328+0800 Block[32567:7900709] &lt;NSMallocBlock: 0x60000025e870&gt; 3. NSStackBlock123456789101112131415161718int a = 10;void(^block)(void) = ^(void) &#123;// NSLog(@&quot;%d&quot;,a);&#125;;block();// NSLog(@&quot;%@&quot;,block);NSLog(@&quot;%@&quot;,^(void) &#123;NSLog(@&quot;%d&quot;,a);&#125;);``` **控制台打印：**&gt;2018-08-04 14:00:38.216673+0800 Block[32615:7906112] &lt;__NSStackBlock__: 0x7ffeeb385b38&gt;***###6\\.block使用场景####①保存代码**1\\.在一个方法中定义，在另一个方法中调用**注：基本不用，有点多此一举 #import “ViewController.h” @interface ViewController () //block怎么声明,就如何定义成属性@property (nonatomic,strong) void(^block)(); @end @implementation ViewController (void)viewDidLoad {[super viewDidLoad]; void(^block)() = ^{NSLog(@”调用了block”);};_block = block; } -(void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event{_block();} @end123**2.在一个类中定义，在另一个类中调用**需求：1.tableview展示3个cell，打电话、发短信、发邮件- **cellItem.h** #import &lt;Foundation/Foundation.h&gt; @interface cellItem : NSObject//设计模型:控件需要展示什么内容,就定义什么属性@property (nonatomic,strong) NSString *title; //保存每个cell做的事情@property (nonatomic,strong) void(^block)(); +(instancetype)itemWitTitle:(NSString *)title; @end 1- **cellItem.m** #import “cellItem.h” @implementation cellItem +(instancetype)itemWitTitle:(NSString )title{cellItem item = [[self alloc]init];item.title = title;return item;}@end1- **JKYTableViewController.m** #import “JKYTableViewController.h” #import “cellItem.h” @interface JKYTableViewController () @property (nonatomic,strong) NSArray *items; @end @implementation JKYTableViewController (void)viewDidLoad {[super viewDidLoad];cellItem item1 = [cellItem itemWitTitle:@”打电话”];cellItem item2 = [cellItem itemWitTitle:@”发短信”];cellItem *item3 = [cellItem itemWitTitle:@”发邮件”];_items = @[item1,item2,item3]; //block保存代码item1.block = ^{NSLog(@”打电话”);};item2.block = ^{NSLog(@”发短信”);};item3.block = ^{NSLog(@”发邮件”);};} -(NSInteger)numberOfSectionsInTableView:(UITableView )tableView{return _items.count;}-(UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath )indexPath{static NSString ID = @”cell”;UITableViewCell cell = [tableView dequeueReusableCellWithIdentifier:ID];if (cell == nil) {cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID];} cellItem *item = self.items[indexPath.row];cell.textLabel.text = item.title; return cell;} -(void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath{cellItem *item = self.items[indexPath.row];if (item.block) {item.block();}}@end 123####②代理传值**需求：** 点击viewController跳转到modalViewController，再将字符串@&quot;123&quot;反向传值给ViewController- **modalViewController.h** #import &lt;UIKit/UIKit.h&gt; @interface modalViewController : UIViewController@property (nonatomic,strong) void(^block)(NSString *value); @end1- **modalViewController.m** #import “modalViewController.h” @interface modalViewController () @end @implementation modalViewController (void)viewDidLoad {[super viewDidLoad];// Do any additional setup after loading the view.} -(void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event{//传值给ViewController//@”123” if (_block) {_block(@”123”);}} @end 1- ** ViewController.m** #import “ViewController.h” #import “modalViewController.h”/**传值:1.只要拿到对方就能传值 顺传:给需要传值的对象,直接定义属性就能传值逆传:用代理,block,就是用block去代替代理 */ @interface ViewController () @end @implementation ViewController -(void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event{modalViewController *modalVC = [[modalViewController alloc]init];modalVC.view.backgroundColor = [UIColor cyanColor]; //modalVC.block = ^(NSString *value) {NSLog(@”%@--%@”,[self class],value);}; [self presentViewController:modalVC animated:YES completion:nil];} (void)viewDidLoad {[super viewDidLoad];}@end1234567891011- **控制台打印：**&gt;2018-08-04 19:09:31.114136+0800 block代理传值[33591:8085166] ViewController--123####③参数使用- **总结**1\\.怎么区分参数是block,就看有没有^,只要有^,就把block当做参数2\\.把block当做参数,并不是马上调用block,什么时候调用由方法内部决定3\\.什么时候把block当做参数使用:做的事情由外界决定,但是什么时候做由内部决定**需求：**封装一个计算器,提供一个计算方法,怎么计算由外界决定,什么时候计算由内部决定- **CalculateManager.h** #import &lt;Foundation/Foundation.h&gt; @interface CalculateManager : NSObject @property (nonatomic,assign) NSInteger result;//计算-(void)calculate:(NSInteger(^)(NSInteger result))calculateBlock; @end1- **CalculateManager.m** #import “CalculateManager.h” @implementation CalculateManager -(void)calculate:(NSInteger (^)(NSInteger))calculateBlock{if (calculateBlock) {_result = calculateBlock(_result);}} @end1- **ViewController.m** #import “ViewController.h” #import “CalculateManager.h” @interface ViewController () @end @implementation ViewController (void)viewDidLoad {[super viewDidLoad]; // [UIView animateWithDuration:0 animations:^{// }]; CalculateManager manageer = [[CalculateManager alloc]init];[manageer calculate:^NSInteger(NSInteger result) {result += 5;result += 6;result = 2;return result;}]; NSLog(@”%ld”,manageer.result); }@end12####④返回值block返回值常见于框架中，如：masonry中常见的链式编程，把所有的语句用**.**号连接起来。好处，可读性强 #import “ViewController.h” @interface ViewController () @end @implementation ViewController (void)viewDidLoad {[super viewDidLoad]; // make.center.equalTo(ws.view);self.test();} -(void(^)())test{NSLog(@”%s”,func);// void(^block)() = ^{//// };// return block; return ^{ NSLog(@”调用了block”); }; } 12**需求：**封装一个计算器,提供一个加号方法- **CalculateManager.h** #import &lt;Foundation/Foundation.h&gt; @interface CalculateManager : NSObject @property (nonatomic,assign) NSInteger reslt; //-(CalculateManager )add:(NSInteger)value;-(CalculateManager (^)(NSInteger))add; @end 1- **CalculateManager.m** #import “CalculateManager.h” @implementation CalculateManager //-(CalculateManager *)add:(NSInteger)value//{// _reslt += value;// return self;//} -(CalculateManager *(^)(NSInteger))add{return ^(NSInteger value){ _reslt += value;return self;};} @end 1- **ViewController.m** #import “ViewController.h” #import “CalculateManager.h” @interface ViewController () @end @implementation ViewController (void)viewDidLoad {[super viewDidLoad]; CalculateManager *manager = [[CalculateManager alloc]init];// [[[manager add:5]add:6]add:7];manager.add(5).add(10).add(20);NSLog(@”%ld”,manager.reslt); } @end 12345678910***###7\\.block内存管理- **block是不是一个对象**查阅苹果官方文档，Block是一个Objective-C对象。Blocks are Objective-C objects。#####MRC######引申**如何判断当前文件是ARC还是MRC？**1.dealloc 能否调用super，只有MRC才能调用super2.能否使用retain，release，如果能用就是MRC -(void)dealloc{[super dealloc];}//ARC环境下报错，ARC forbids explicit message send of ‘dealloc’123456789101112131415161718- **MRC了解常识：**1.MRC没有strong、weak、局部变量对象2.MRC给成员属性赋值，一定要使用set方法，不能直接访问下划线成员属性赋值- **MRC：管理block**⭐️⭐️⭐️1\\.只要block没有引用外部局部变量，block放在全局区2\\.只要block引用外部局部变量，block放在栈里面3\\.blcok只能使用copy，不能使用retain，使用retain，block还是在栈里面***#####ARC- **ARC管理原则：**只要有一个对象没有被强指针修饰就会被销毁，默认局部变量对象都是强指针，存放到堆里面- **ARC：管理block**⭐️⭐️⭐️1\\.只要block引用外部局部变量，block放在堆里面2\\.block使用strong，最好不要使用copy***###8\\.block循环引用 (void)viewDidLoad {[super viewDidLoad]; //block造成循环引用:Block会对里面所有外部变量对象全部强引用 __weak typeof(self) weakSelf = self;_block = ^{NSLog(@”%@”,weakSelf); __strong typeof(weakSelf) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@”%@”,strongSelf);}); }; _block();} 1234###9\\.block变量传递- **总结**1\\.如果是局部变量，block是值传递2\\.如果是静态变量、全局变量、__block修饰的变量，block都是指针传递 (void)viewDidLoad {[super viewDidLoad]; //1.static int a = 3;//2.int a = 3;void(^block)() = ^() {NSLog(@”%d”,a);}; a = 5; block();}`控制台：1.static int a = 3; 2018-08-04 21:21:24.733048+0800 block变量传递[34240:8168797] 5 2.int a = 3; 2018-08-04 21:22:26.695827+0800 block变量传递[34254:8170195] 3","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Block","slug":"Block","permalink":"http://yoursite.com/tags/Block/"}],"keywords":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}]},{"title":"iOS-多图下载","slug":"iOS-多图下载","date":"2019-01-05T12:01:34.000Z","updated":"2019-04-29T02:30:48.082Z","comments":true,"path":"2019/01/05/iOS-多图下载/","link":"","permalink":"http://yoursite.com/2019/01/05/iOS-多图下载/","excerpt":"","text":"###1.iOS多图下载的缓存处理### 需求在tableview的每一个cell里显示从网络下载的图片 Demo12345678910111213141516171819202122232425262728-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;static NSString *ID = @&quot;app&quot;;//1.创建cellUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];//2.设置cell数据//2.1拿到该行cell对应的数据JKYApp *appM = self.apps[indexPath.row];cell.textLabel.text = appM.name;cell.detailTextLabel.text = appM.download;//设置图标UIImage *image = [self.imageDic objectForKey:appM.icon];if (image) &#123;cell.imageView.image = image;&#125;else&#123;NSURL *url = [NSURL URLWithString:appM.icon];NSData *imageData = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:imageData];cell.imageView.image = image;//将图片保存到内存缓存[self.imageDic setObject:image forKey:appM.icon];&#125;//3.返回cellreturn cell;&#125; ###2.造成的问题 1.UI不流畅dataWithContentsOfURL：是耗时操作，将其放在主线程会造成卡顿。如果图片很多，图片很大，而且网络情况不好的话会造成用户体验极差 2.图片重复下载由于没有缓存机制，即使下载完成并显示了当前cell的图片，但是当该cell再一次滚动，显示的时候还是会下载它所对应的图片，耗费了下载流量，而且还导致重复操作。 ###3.解决方案 注: 原图是大神J_Knight_文章里下载的，还有下面这一节内容也是来源于J_Knight_老师，觉得挺好的就拿过来知识点复习汇总了，如有冒犯必定立即删除。 图片的URL：因为每张图片对应的URL都是唯一的，所以我们可以通过它来建立图片缓存和下载操作的缓存的键，以及拼接沙盒缓存的路径字符串。 图片缓存（字典）：存放于内存中；键为图片的URL，值为UIImage对象。作用：读取速度快，直接使用UIImage对象。 下载操作缓存（字典）：存放与内存中，键为图片的URL，值为NSBlockOperation对象。作用：用来避免对于同一张图片还要开启多个下载线程。 沙盒缓存(文件路径对应NSData)：存放于磁盘中，位于Cache文件夹内，路径为“Cache/图片URL的最后的部分”，值为NSData对象（将UIImage转化为NSData才能写入磁盘里）。作用：程序断网，再次启动也可以直接在磁盘中拿到图片。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//先去查看内存缓存中该图片时候已经存在,如果存在那么久直接拿来用,否则去检查磁盘缓存//如果有磁盘缓存,那么保存一份到内存,设置图片,否则就直接下载//1)没有下载过//2)重新打开程序UIImage *image = [self.images objectForKey:appM.icon];if (image) &#123;cell.imageView.image = image;NSLog(@&quot;%zd处的图片使用了内存缓存中的图片&quot;,indexPath.row) ;&#125;else&#123;//保存图片到沙盒缓存NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];//获得图片的名称,不能包含/NSString *fileName = [appM.icon lastPathComponent];//拼接图片的全路径NSString *fullPath = [caches stringByAppendingPathComponent:fileName];//检查磁盘缓存NSData *imageData = [NSData dataWithContentsOfFile:fullPath];//废除imageData = nil;if (imageData) &#123;UIImage *image = [UIImage imageWithData:imageData];cell.imageView.image = image;NSLog(@&quot;%zd处的图片使用了磁盘缓存中的图片&quot;,indexPath.row) ;//把图片保存到内存缓存[self.images setObject:image forKey:appM.icon];// NSLog(@&quot;%@&quot;,fullPath);&#125;else&#123;//检查该图片时候正在下载,如果是那么久什么都捕捉,否则再添加下载任务NSBlockOperation *download = [self.operations objectForKey:appM.icon];if (download) &#123;&#125;else&#123;//先清空cell原来的图片cell.imageView.image = [UIImage imageNamed:@&quot;Snip20160221_306&quot;];download = [NSBlockOperation blockOperationWithBlock:^&#123;NSURL *url = [NSURL URLWithString:appM.icon];NSData *imageData = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:imageData];NSLog(@&quot;%zd--下载---&quot;,indexPath.row);//容错处理if (image == nil) &#123;[self.operations removeObjectForKey:appM.icon];return ;&#125;//演示网速慢的情况//[NSThread sleepForTimeInterval:3.0];//把图片保存到内存缓存[self.images setObject:image forKey:appM.icon];//NSLog(@&quot;Download---%@&quot;,[NSThread currentThread]);//线程间通信[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;//cell.imageView.image = image;//刷新一行[self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationLeft];//NSLog(@&quot;UI---%@&quot;,[NSThread currentThread]);&#125;];//写数据到沙盒[imageData writeToFile:fullPath atomically:YES];//移除图片的下载操作[self.operations removeObjectForKey:appM.icon];&#125;];//添加操作到操作缓存中[self.operations setObject:download forKey:appM.icon];//添加操作到队列中[self.queue addOperation:download]; &#125; &#125;&#125;//3.返回cellreturn cell; ###4.内存警告处理###1234567-(void)didReceiveMemoryWarning&#123;[self.images removeAllObjects];//取消队列中所有的操作[self.queue cancelAllOperations];&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}],"keywords":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}]}]}