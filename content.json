{"meta":{"title":"小金渣blog","subtitle":null,"description":null,"author":"小金渣","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"面试题知识点梳理","slug":"面试题知识点梳理","date":"2019-05-06T04:49:08.000Z","updated":"2019-05-15T01:10:33.087Z","comments":true,"path":"2019/05/06/面试题知识点梳理/","link":"","permalink":"http://yoursite.com/2019/05/06/面试题知识点梳理/","excerpt":"","text":"基础知识1.设计模式是什么？ 你知道哪些设计模式，并简要叙述？设计模式是一种编码经验，用比较成熟的逻辑去处理某一类型的事情 MVC模式：Model View Control，把模型、视图、控制器层进行解耦合编写 MVVM模式：Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写 单例模式：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次 观察者模式：KVO是典型的观察者模式，观察某个属性的状态，状态发生变化时通知观察者 委托模式：代理+协议的组合。实现1对1的反向传值操作 工厂模式：通过一个类方法，批量的根据已有模板生产对象 2.MVC 和 MVVM 的区别MVC模式（Model-View-Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 视图层（View），是直接面向最终用户的。它是提供给用户的操作界面，是程序的外壳 数据层（Model），是核心的，也就是程序需要操作的数据或信息 控制层（Controller），它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果 三个模块之间都是可以通信的，不过都是单向通信。 1.View 传送指令到 Controller 2.Controller 完成业务逻辑后，要求 Model 改变状态 3.Model 将新的数据发送到 View，用户得到反馈 MVP模式(Model-View-Presenter)模块间的通信是相互的，但View和Model之间的通信是绝对禁止的。 1.Presenter（英文中翻译是：主持人，主办方），View和Model之间的通信必须是通过Presenter来进行传达的 2.所有的业务逻辑都是放在Presenter中（这样会显的比较臃肿，具体设计时，要注意对它进行“瘦身”） 3.View只是负责展示数据就行了（没有主动性），由Presenter决定去Model中拿什么样的数据 MVVM模式(Model-View-ViewModel) 1.MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 2.唯一的区别就是，View和ViewModel之间是“双向绑定“的，View的变动，自动反映在 ViewModel，反之亦然。 3.MVVM可以降低UI显示与后端逻辑代码的耦合度，即更换界面时，只需要修改很少的逻辑代码就可以实现，甚至不用修改。 MVVM是对胖模型进行的拆分，其本质是给控制器减负，将一些弱业务逻辑放到VM中去处理。 MVC是一切设计的基础，所有新的设计模式都是基于MVC进行的改进 3.#import跟 #include 有什么区别，@class呢，#import&lt;&gt; 跟 #import””有什么区别？ #import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动只导入一次，不会重复导入 @class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含 #import&lt;&gt;用来包含系统的头文件，#import””用来包含用户头文件 4.frame 和 bounds 有什么不同？ frame指的是：该view在父view坐标系统中的位置和大小。(参照点是父view的坐标系统) bounds指的是：该view在本身坐标系统中的位置和大小。(参照点是本身坐标系统) 5.Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方法用继承好还是分类好？为什么？ Objective-C的类不可以多重继承，可以实现多个接口（协议） Category是类别 一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系 6.@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的 @property 的本质是什么？ @property = ivar + getter + setter; “属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法） “属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。 7.@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？属性可以拥有的特质分为四类: 1.原子性— nonatomic 特质 2.读/写权限—readwrite(读写)、readonly (只读) 3.内存管理语义—assign、strong、 weak、unsafe_unretained、copy 4.方法名—getter= 、setter= 5.不常用的：nonnull,null_resettable,nullable 8.属性关键字 readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用？ 1.readwrite 是可读可写特性。需要生成getter方法和setter方法 2.readonly 是只读特性。只会生成getter方法，不会生成setter方法，不希望属性在类外改变 3.assign 是赋值特性。setter方法将传入参数赋值给实例变量;仅设置变量时,assign用于基本数据类型 4.retain(MRC)/strong(ARC) 表示持有特性。setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1 5.copy 表示拷贝特性。setter方法将传入对象复制一份，需要完全一份新的变量时 nonatomic 非原子操作。不写的话默认就是atomic。atomic 和 nonatomic 的区别在于，系统自动生成的 getter/setter 方法不一样。对于atomic的属性，系统生成的 getter/setter 会保证 get、set 操作的完整性，而nonatomic就没有这个保证了。所以，nonatomic的速度要比atomic快。不过atomic可并不能保证线程安全 9.什么情况使用 weak 关键字，相比 assign 有什么不同？ 1.在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性 2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。 IBOutlet连出来的视图属性为什么可以被设置成weak?因为父控件的subViews数组已经对它有一个强引用 不同点： assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。 weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil) 10.怎么用 copy 关键字？用途 NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary block 也经常使用 copy 关键字 说明 block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。 11.用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？答： 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性 总结： 使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值 12.浅拷贝和深拷贝的区别？ 浅拷贝：只复制指向对象的指针，而不复制引用对象本身 深拷贝：复制引用对象本身。内存中存在了两份独立对象本身，当修改A时，A_copy不变 13.这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *arr;问题： 添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃。例如： -[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460// copy后返回的是不可变对象（即 arr 是 NSArray 类型，NSArray 类型对象不能调用 NSMutableArray 类型对象的方法）原因： 是因为 copy 就是复制一个不可变 NSArray 的对象，不能对 NSArray 对象进行添加/修改。 14.如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？ 若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。 具体步骤 需声明该类遵从 NSCopying 协议 实现 NSCopying 协议的方法 该协议只有一个方法:1 -(id)copyWithZone:(NSZone *)zone; // 注意：使用 copy 修饰符，调用的是copy方法，其实真正需要实现的是 “copyWithZone” 方法。 15.@synthesize 和 @dynamic 分别有什么作用？ @property有两个对应的词，一个是@synthesize（合成实例变量），一个是@dynamic 如果@synthesize和@dynamic都没有写，那么默认的就是 @synthesize var = _var; 在类的实现代码里通过 @synthesize 语法可以来指定实例变量的名字。(@synthesize var = _newVar;) @synthesize 的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法 @dynamic 告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成（如，@dynamic var） 16.常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int Objective-C的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象 C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值 NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是long。 17.id 声明的对象有什么特性？ id 声明的对象具有运行时的特性，即可以指向任意类型的Objcetive-C的对象。 18.Objective-C 如何对内存管理的，说说你的看法和解决方法？ 答： Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。 自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码 手动内存计数MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则 内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响 19.Objective-C 中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？线程创建有三种方法： 使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue 在主线程执行代码，方法是performSelectorOnMainThread 延时执行代码可以用performSelector:onThread:withObject:waitUntilDone: 20.Category（类别）、 Extension（扩展）和继承的区别？区别： 分类有名字，类扩展没有分类名字，是一种特殊的分类 分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法 继承可以增加，修改或者删除方法，并且可以增加属性 21.我们说的OC是动态运行时语言是什么意思？答： 主要是将数据类型的确定由编译时，推迟到了运行时。简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法 22.为什么我们常见的delegate属性都用是week而不是retain/strong？答： 是为了防止delegate两端产生不必要的循环引用。 @property (nonatomic, weak) id delegate; 23.什么时候用delete，什么时候用Notification？ Delegate(委托模式)：1对1的反向消息通知功能 Notification(通知模式)：只想要把消息发送出去，告知某些状态的变化。但是并不关心谁想要知道这个 24.什么是 KVO 和 KVC？KVC(Key-Value-Coding): 键值编码 是一种通过字符串间接访问对象的方式（即给属性赋值） KVO(key-Value-Observing)：键值观察机制 他提供了观察某一属性变化的方法，极大的简化了代码；KVO只能被KVC触发，包括使用setValue:forKey:方法和点语法12345// 通过下方方法为属性添加KVO观察- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;// 当被观察的属性发送变化时，会自动触发下方方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context; 注意: KVC 和 KVO 的 keyPath 可以是属性、实例变量、成员变量。 25.KVC的底层实现？当一个对象调用setValue方法时，方法内部会做以下操作： 1.检查是否存在相应的key的set方法，如果存在，就调用set方法。 2.如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值 3.如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值 4.如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法 这些方法的默认实现都是抛出异常，我们可以根据需要重写它们 26.KVO的底层实现？ KVO基于runtime机制实现 探究KVO的底层实现原理 27.ViewController生命周期按照执行顺序排列： initWithCoder：通过nib文件初始化时触发 awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象 loadView：开始加载视图控制器自带的view viewDidLoad：视图控制器的view被加载完成 viewWillAppear：视图控制器的view将要显示在window上 updateViewConstraints：视图控制器的view开始更新AutoLayout约束 viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置 viewDidLayoutSubviews：视图控制器的view已经更新视图的位置 viewDidAppear：视图控制器的view已经展示到window上 viewWillDisappear：视图控制器的view将要从window上消失 viewDidDisappear：视图控制器的view已经从window上消失 28.方法和选择器有何不同？ selector是一个方法的名字，方法是一个组合体，包含了名字和实现 29.你是否接触过OC中的反射机制？简单聊一下概念和使用class反射 通过类名的字符串形式实例化对象 Class class = NSClassFromString(@”student”); Student *stu = [[class alloc] init]; 将类名变为字符串 Class class =[Student class]; NSString *className = NSStringFromClass(class); SEL的反射 通过方法的字符串形式实例化方法 SEL selector = NSSelectorFromString(@”setName”); [stu performSelector:selector withObject:@”Jin”]; 将方法变成字符串 NSStringFromSelector(@selector*(setName:)); 30.调用方法的两种方式？ 直接通过方法名来调用。[person show]; 间接的通过SEL数据来调用 。SEL aaa = @selector(show); [person performSelector:aaa]; 31.如何对iOS设备进行性能测试？答： Profile-&gt; Instruments -&gt;Time Profiler 32.开发项目时你是怎么检查内存泄露？ 静态分析 analyze instruments工具里面有个leak可以动态分析 ** 32.什么是懒加载？答： 懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。例： 最好也最简单的一个例子就是tableView中图片的加载显示了, 一个延时加载, 避免内存过高,一个异步加载,避免线程堵塞提高用户体验。 33.类变量的 @public，@protected，@private，@package 声明各有什么含义？ @public任何地方都能访问 @protected该类和子类中访问,是默认的 @private只能在本类中访问 @package本包内使用,跨包不可以 34.什么是谓词？谓词就是通过NSPredicate给定的逻辑条件作为约束条件,完成对数据的筛选12345//定义谓词对象,谓词对象中包含了过滤条件(过滤条件比较多)NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;age&lt;%d&quot;,30];//使用谓词条件过滤数组中的元素,过滤之后返回查询的结果NSArray *array = [persons filteredArrayUsingPredicate:predicate]; 35.isa指针问题 isa：是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类,而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调 用时,先会从本身查找类方法的实现,如果没有,元类会向他父类查找该方法。同时注意的是:元类(meteClass)也是类,它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass)。根元类的isa指针指向本身,这样形成了一个封闭的内循环。 36.如何访问并修改一个类的私有属性？ 一种是通过KVC获取 通过runtime访问并修改私有属性 37.一个objc对象的isa的指针指向什么？有什么作用？答： 指向他的类对象,从而可以找到对象上的方法 38.下面的代码输出什么？12345678910@implementation Son : Father- (id)init &#123;if (self = [super init]) &#123;NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); // SonNSLog(@&quot;%@&quot;, NSStringFromClass([super class])); // Son&#125;return self;&#125;@end 解析： self 是类的隐藏参数，指向当前调用方法的这个类的实例 super是一个Magic Keyword，它本质是一个编译器标示符，和self是指向的同一个消息接收者 不同的是：super会告诉编译器，调用class这个方法时，要去父类的方法，而不是本类里的 上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son *obj 这个对象 39.isKindOfClass、isMemberOfClass、selector作用分别是什么? isKindOfClass: 作用是某个对象属于某个类型或者继承自某类型 isMemberOfClass: 某个对象确切属于某个类型 selector: 通过方法名，获取在内存中的函数的入口地址 40.delegate 和 notification 的区别? 1.二者都用于传递消息，不同之处主要在于一个是一对一的，另一个是一对多的 2.notification通过维护一个array，实现一对多消息的转发 3.delegate需要两者之间必须建立联系，不然没法调用代理的方法；notification不需要两者之间有联系 41.什么是block？闭包（block）： 闭包就是获取其它函数局部变量的匿名函数 42.block反向传值 iOS-Block 43.block的注意点 1.在block内部使用外部指针且会造成循环引用情况下，需要用week修饰外部指针： weak typeof(self) weakSelf = self; 2.在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在block内部再将弱指针重新强引用一下。 __strong typeof(self) strongSelf = weakSelf; 3.如果需要在block内部改变外部栈区变量的话，需要在用__block修饰外部变量 44.BAD_ACCESS在什么情况下出现？答： 这种问题在开发时经常遇到。原因是访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。 45.lldb（gdb）常用的控制台调试命令？ 1.p 输出基本类型。是打印命令，需要指定类型。是print的简写 p (int)[[[self view] subviews] count] 2.po 打印对象，会调用对象description方法。是print-object的简写 po [self view] 3.expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值 4.bt：打印调用堆栈，是thread backtrace的简写，加all可打印所有thread的堆栈 5.br l：是breakpoint list的简写 46.你一般是怎么用Instruments的？Instruments里面工具很多，常用： Time Profiler: 性能分析 Zombies：检查是否访问了僵尸对象，但是这个工具只能从上往下检查，不智能 Allocations：用来检查内存，写算法的那批人也用这个来检查 Leaks：检查内存，看是否有内存泄露 47.iOS中常用的数据存储方式有哪些？？？？？？？？？？？？数据存储有四种方案：NSUserDefault、KeyChain、File、DB。其中File有三种方式：writeToFile:atomically:、Plist、NSKeyedAchiever（归档）DB包括：SQLite、FMDB、CoreData 48.iOS的沙盒目录结构是怎样的？沙盒结构： AppName.app 目录：这是应用程序的程序包目录，包含应用程序的本身。由于应用程序必须经过签名，所以您在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动 Documents：您应该将所有的应用程序数据文件写入到这个目录下。这个目录用于存储用户数据。iCloud备份目录。（这里不能存缓存文件，否则上架不被通过） Library 目录：这个目录下有两个子目录：① Preferences 目录：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好② Caches 目录：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。 可创建子文件夹。可以用来放置您希望被备份但不希望被用户看到的数据。该路径下的文件夹，除Caches以外，都会被iTunes备份。 tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。 49.iOS多线程技术有哪几种方式？答： pthread、NSThread、GCD、NSOperation 50.GCD 与 NSOperation 的区别？ GCD 和 NSOperation 都是用于实现多线程 GCD 基于C语言的底层API，GCD主要与block结合使用，代码简洁高效 NSOperation 属于Objective-C类，是基于GCD更高一层的封装。复杂任务一般用NSOperation实现。 51.写出使用GCD方式从子线程回到主线程的方法代码？1dispatch_sync(dispatch_get_main_queue(), ^&#123; &#125;); 52.如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）1234567891011121314151617// 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。// 创建队列组dispatch_group_t group = dispatch_group_create();// 获取全局并发队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_async(group, queue, ^&#123; /*加载图片1 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片2 */ &#125;);dispatch_group_async(group, queue, ^&#123; /*加载图片3 */ &#125;);// 当并发队列组中的任务执行完毕后才会执行这里的代码dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;// 合并图片&#125;); 53.dispatch_barrier_async（栅栏函数）的作用是什么？定义1dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block); 作用 1.在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行 2.避免数据竞争12345678910111213141516171819// 1.创建并发队列 dispatch_queue_t queue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);// 2.向队列中添加任务 dispatch_async(queue, ^&#123; // 1.2是并行的 NSLog(@&quot;任务1, %@&quot;,[NSThread currentThread]);&#125;); dispatch_async(queue, ^&#123; NSLog(@&quot;任务2, %@&quot;,[NSThread currentThread]);&#125;);dispatch_barrier_async(queue, ^&#123; NSLog(@&quot;任务 barrier, %@&quot;, [NSThread currentThread]);&#125;); dispatch_async(queue, ^&#123; // 这两个是同时执行的 NSLog(@&quot;任务3, %@&quot;,[NSThread currentThread]);&#125;); dispatch_async(queue, ^&#123; NSLog(@&quot;任务4, %@&quot;,[NSThread currentThread]);&#125;); // 输出结果: 任务1 任务2 ——》 任务 barrier ——》任务3 任务4 // 其中的任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。 54.以下代码运行结果如何？12345678- (void)viewDidLoad &#123;[super viewDidLoad]; NSLog(@&quot;1&quot;); dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;2&quot;);&#125;); NSLog(@&quot;3&quot;);&#125; // 只输出：1。（主线程死锁） 55.什么是 RunLoop? 从字面上看，就是运行循环，跑圈 其实它内部就是do-while循环，在这个循环内部不断地处理各种任务（比如Source、Timer、Observer） 一个线程对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。 通过runloop，有事运行，没事就休息，可以节省cpu资源，提高程序性能。 主线程的run loop默认是启动的。iOS的应用程序里面，程序启动后会有一个如下的main()函数 12345 int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125; &#125; 56.说说你对 runtime 的理解？ Runtime又叫运行时，是一套底层的C语言API，其为iOS内部的核心之一，我们平时编写的OC代码，底层都是基于它来实现的。 57.Runtime实现的机制是什么，怎么用，一般用于干嘛？ 1.使用时需要导入的头文件 2.Runtime 运行时机制，它是一套C语言库 3.实际上我们编写的所有OC代码，最终都是转成了runtime库的东西。比如： 类转成了 Runtime 库里面的结构体等数据类型， 方法转成了 Runtime 库里面的C语言函数， 平时调方法都是转成了 objc_msgSend 函数（所以说OC有个消息发送机制） // OC是动态语言，每个方法在运行时会被动态转为消息发送即：objc_msgSend(receiver, selector)。 // [stu show]; 在objc动态编译时，会被转意为：objc_msgSend(stu, @selector(show)); 4.可以说 Runtime 是OC的底层实现，是OC的幕后执行者。 有了Runtime库，能做什么事情呢？ Runtime库里面包含了跟类、成员变量、方法相关的API。比如：①获取类里面的所有成员变量。②为类动态添加成员变量。 ③为类动态添加新的方法。 ④动态改变类的方法实现等。(Method Swizzling) 因此，有了Runtime，想怎么改就怎么改。 iOS：学习runtime的理解和心得 58.什么是 Method Swizzle（黑魔法），什么情况下会使用？ 在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法 Method Swizzle 2.Method Swizzle 指的是改变一个已存在的选择器对应的实现的过程。OC中方法的调用能够在运行时通过改变，通过改变类的调度表中选择器到最终函数间的映射关系 3.在OC中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用OC的动态特性，可以实现在运行时偷换selector对应的方法实现 4.每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的方法实现 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP 6.我们可以利用 class_replaceMethod 来修改类 7.我们可以利用 method_setImplementation 来直接设置某个方法的IMP 8.归根结底，都是偷换了selector的IMP 59._objc_msgForward 函数是做什么的，直接调用它将会发生什么？答： _objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。 60.什么是 TCP / UDP ?TCP： 传输控制协议。UDP： 用户数据协议。 TCP 是面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。 UDP 是面向无连接的，数据传输是不可靠的，它只管发，不管收不收得到。 简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般。 61.通信底层原理（OSI七层模型）OSI采用了分层的结构化技术，共分七层： 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 62.介绍一下XMPP？XMPP是一种以XML为基础的开放式实时通信协议。 简单的说，XMPP就是一种协议，一种规定。就是说，在网络上传东西，XMM就是规定你上传大小的格式。 63.OC中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？1234567891011 // 创建线程的方法 - [NSThread detachNewThreadSelector:nil toTarget:nil withObject:nil] - [self performSelectorInBackground:nil withObject:nil]; - [[NSThread alloc] initWithTarget:nil selector:nil object:nil]; - dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;&#125;); - [[NSOperationQueue new] addOperation:nil]; // 主线程中执行代码的方法 - [self performSelectorOnMainThread:nil withObject:nil waitUntilDone:YES]; - dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;); - [[NSOperationQueue mainQueue] addOperation:nil]; 64.tableView的重用机制？答： UITableView 通过重用单元格来达到节省内存的目的: 通过为每个单元格指定一个重用标识符，即指定了单元格的种类,当屏幕上的单元格滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元格从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，如果有，就拿过来用，如果没有就创建一个来使用。 65.用伪代码写一个线程安全的单例模式12345678910111213 static id _instance; + (id)allocWithZone:(struct _NSZone *)zone &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _instance = [super allocWithZone:zone]; &#125;); return _instance; &#125; + (instancetype)sharedData &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _instance = [[self alloc] init]; &#125;); return _instance; &#125; - (id)copyWithZone:(NSZone *)zone &#123; return _instance; &#125; 66.如何实现视图的变形?答： 通过修改view的 transform 属性即可。 67.在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？答： UITapGestureRecognizer,UISwipeGestureRecognizer是一次性手势,手势发生后,响应只会执行一次。 68.字符串常用方法？123 NSString str = @&quot;abc123&quot;; NSArray arr = [str componentsSeparatedByString:@&quot;&quot;]; //以目标字符串把原字符串分割成两部分，存到数组中。@[@&quot;abc&quot;, @&quot;123&quot;]; 69.如何高性能的给 UIImageView 加个圆角? 不好的解决方案：使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制, 而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现。 1 self.view.layer.cornerRadius = 5.0f; self.view.layer.masksToBounds = YES; 正确的解决方案：使用绘图技术 1234567891011121314 - (UIImage *)circleImage &#123; // NO代表透明 UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0); // 获得上下文 CGContextRef ctx = UIGraphicsGetCurrentContext(); // 添加一个圆 CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height); CGContextAddEllipseInRect(ctx, rect); // 裁剪 CGContextClip(ctx); // 将图片画上去 [self drawInRect:rect]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); // 关闭上下文 UIGraphicsEndImageContext(); return image; &#125; 还有一种方案：使用了贝塞尔曲线”切割”个这个图片, 给UIImageView 添加了的圆角，其实也是通过绘图技术来实现的。 12345678 UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)]; imageView.center = CGPointMake(200, 300); UIImage *anotherImage = [UIImage imageNamed:@&quot;image&quot;]; UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0); [[UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:50] addClip]; [anotherImage drawInRect:imageView.bounds]; imageView.image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); [self.view addSubview:imageView]; 70.你是怎么封装一个view的？ 1.可以通过纯代码或者xib的方式来封装子控件 2.建立一个跟view相关的模型，然后将模型数据传给view，通过模型上的数据给view的子控件赋值 /** 纯代码初始化控件时一定会走这个方法 12345 - (instancetype)initWithFrame:(CGRect)frame &#123; if(self = [super initWithFrame:frame]) &#123; [self setupUI]; &#125; return self; &#125; 通过xib初始化控件时一定会走这个方法 123456 - (id)initWithCoder:(NSCoder *)aDecoder &#123; if(self = [super initWithCoder:aDecoder]) &#123; [self setupUI]; &#125; return self; &#125; - (void)setupUI &#123; // 初始化代码 &#125; 71.HTTP协议中 POST 方法和 GET 方法有那些区别? GET用于向服务器请求数据，POST用于提交数据 GET请求，请求参数拼接形式暴露在地址栏，而POST请求参数则放在请求体里面，因此GET请求不适合用于验证密码等操作 GET请求的URL有长度限制，POST请求不会有长度限制 72.请简单的介绍下APNS发送系统消息的机制 APNS优势： 杜绝了类似安卓那种为了接受通知不停在后台唤醒程序保持长连接的行为，由iOS系统和APNS进行长连接替代。 APNS的原理： 1.应用在通知中心注册，由iOS系统向APNS请求返回设备令牌(device Token) 2.应用程序接收到设备令牌并发送给自己的后台服务器 3.服务器把要推送的内容和设备发送给APNS 4.APNS根据设备令牌找到设备，再由iOS根据APPID把推送内容展示 73. ios开发逆向传值的几种方法整理 第一种：代理传值 12345678910111213141516171819202122232425 //第二个控制器： @protocol WJSecondViewControllerDelegate - (void)changeText:(NSString*)text; @end @property(nonatomic,assign)iddelegate; - (IBAction)buttonClick:(UIButton*)sender &#123; _str = sender.titleLabel.text; [self.delegate changeText:sender.titleLabel.text]; [self.navigationController popViewControllerAnimated:YES]; &#125; //第一个控制器: - (IBAction)pushToSecond:(id)sender &#123; WJSecondViewController *svc = [[WJSecondViewController alloc]initWithNibName:@&quot;WJSecondViewController&quot; bundle:nil]; svc.delegate = self; svc.str = self.navigationItem.title; [self.navigationController pushViewController:svc animated:YES]; [svc release]; &#125; - (void)changeText:(NSString *)text&#123; self.navigationItem.title = text; &#125; 第二种：通知传值 1234567891011 //第一个控制器： //注册监听通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(limitDataForModel:) name:@&quot;NOV&quot; object:nil]; - (void)limitDataForModel:(NSNotification *)noti&#123; self.gamesInfoArray = noti.object; &#125; // 第二个控制器： //发送通知 [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;NOV&quot; object:gameArray]; 第三种：单例传值 12345678910111213141516 //Single是一个单例类，并且有一个字符串类型的属性titleName //在第二个控制器： - (IBAction)buttonClick:(UIButton*)sender &#123; Single *single = [Single sharedSingle]; single.titleName = sender.titleLabel.text; [self.navigationController popViewControllerAnimated:YES]; &#125; //第一个控制器： - (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; Single *single = [Single sharedSingle]; self.navigationItem.title = single.titleName; &#125; 第四种：block传值 12345678910111213141516171819 //第二个控制器： @property (nonatomic,copy) void (^changeText_block)(NSString*); - (IBAction)buttonClick:(UIButton*)sender &#123; _str = sender.titleLabel.text; self.changeText_block(sender.titleLabel.text); [self.navigationController popViewControllerAnimated:YES]; &#125; //第一个控制器： - (IBAction)pushToSecond:(id)sender &#123; WJSecondViewController *svc = [[WJSecondViewController alloc]initWithNibName:@&quot;WJSecondViewController&quot; bundle:nil]; svc.str = self.navigationItem.title; [svc setChangeText_block:^(NSString *str) &#123; &gt;self.navigationItem.title = str; &#125;]； [self.navigationController pushViewController:svc animated:YES]; &#125; 第五种：extern传值 123456789101112 //第二个控制器： extern NSString *btn; - (IBAction)buttonClick:(UIButton*)sender &#123; btn = sender.titleLabel.text; [self.navigationController popViewControllerAnimated:YES]; &#125; //第一个控制器: NSString *btn = nil; - (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; self.navigationItem.title = btn; &#125; 第六种：KVO传值 123456789101112 //第一个控制器: - (void)viewDidLoad &#123; [super viewDidLoad]; _vc =[[SecondViewController alloc]init]; //self监听vc里的textValue属性 [_vc addObserver:self forKeyPath:@&quot;textValue&quot; options:0 context:nil]; &#125; //第二个控制器: - (IBAction)buttonClicked:(id)sender &#123; self.textValue = self.textField.text; [self.navigationController popViewControllerAnimated:YES]; &#125; 74.浅谈iOS开发中方法延迟执行的几种方式 Method1. performSelector方法 Method2. NSTimer定时器 Method3. NSThread线程的sleep Method4. GCD 公用延迟执行方法 1 - (void)delayMethod&#123; NSLog(@&quot;delayMethodEnd&quot;); Method1: performSelector 123 [self performSelector:@selector(delayMethod) withObject:nil/*可传任意类型参数*/ afterDelay:2.0];` //注：此方法是一种非阻塞的执行方式，未找到取消执行的方法。 Method2: NSTimer定时器 12 NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(delayMethod) userInfo:nil repeats:NO]; //注：此方法是一种非阻塞的执行方式 取消执行方法：- (void)invalidate;即可 Method3: NSThread线程的sleep 12 [NSThread sleepForTimeInterval:2.0]; //注：此方法是一种阻塞执行方式，建议放在子线程中执行，否则会卡住界面。但有时还是需要阻塞执行，如进入欢迎界面需要沉睡3秒才进入主界面时。 Method4: GCD 12345 __block ViewController weakSelf = self; dispatch_time_t delayTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0/*延迟执行时间*/ * NSEC_PER_SEC)); dispatch_after(delayTime, dispatch_get_main_queue(), ^&#123; [weakSelf delayMethod]; &#125;); //注：此方法可以在参数中选择执行的线程，是一种非阻塞执行方式。没有找到取消执行方式。 75.NSPersistentStoreCoordinator , NSManaged0bjectContext 和NSManaged0bject中的那些需要在线程中创建或者传递？ 答： NSPersistentStoreCoordinator是持久化存储协调者，主要用于协调托管对象上下文和持久化存储区之间的关系。NSManagedObjectContext使用协调者的托管对象模型将数据保存到数据库，或查询数据。 76.您是否做过一部的网络处理和通讯方面的工作？如果有，能具体介绍一下实现策略么? 答： 使用NSOperation发送异步网络请求，使用NSOperationQueue管理线程数目及优先级，底层是用NSURLConnetion。 77.你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？ Objecitve-C的重要特性是Runtime（运行时）,在#import 下能看到相关的方法，用过objc_getClass()和class_copyMethodList()获取过私有API; 使用Method method1 = class_getInstanceMethod(cls, sel1);Method method2 = class_getInstanceMethod(cls, sel2);method_exchangeImplementations(method1, method2);代码交换两个方法，在写unit test时使用到。 78.Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics。UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容） 答： UI框架的底层有CoreAnimation，CoreAnimation的底层有CoreGraphics。 UIKit Core Animation Core Graphics Graphics Hardware 补充完善 79.是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。 答： CoreText可以解决复杂文字内容排版问题。CoreImage可以处理图片，为其添加各种效果。体验是很强大，挺复杂的。 80.自动释放池是什么,如何工作？ 答： 当您向一个对象发送一个autorelease消息时，Cocoa就会将该对象的一个引用放入到最新的自动释放.它仍然是个OC的对象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。 81.NSNotification和KVO的区别和用法是什么？什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么？ 答： NSNotification是通知模式在iOS的实现，KVO的全称是键值观察(Key-value observing),其是基于KVC（key-value coding）的，KVC是一个通过属性名访问属性变量的机制。 例如将Module层的变化，通知到多个Controller对象时，可以使用NSNotification；如果是只需要观察某个对象的某个属性，可以使用KVO 对于委托模式，在设计模式中是对象适配器模式，其是delegate是指向某个对象的，这是一对一的关系，而在通知模式中，往往是一对多的关系。 委托模式，从技术上可以现在改变delegate指向的对象，但不建议这样做，会让人迷惑，如果一个delegate对象不断改变，指向不同的对象。 81.你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和G.C.D的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述） 答： 使用NSOperationQueue用来管理子类化的NSOperation对象，控制其线程并发数目。 GCD和NSOperation都可以实现对线程的管理，区别是 NSOperation和NSOperationQueue是多线程的面向对象抽象。 项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点（复用、封装），使得实现是多线程支持，而接口简单，建议在复杂项目中使用 项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用 82.既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么？ 答： 使用block是要注意，若将block做函数参数时，需要把它放到最后 GCD是Grand Central Dispatch，是一个对线程开源类库 而Block是闭包，是能够读取其他函数内部变量的函数。 83.对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？ 答： 最大的优点是它的运行时特性，不足是没有命名空间，对于命名冲突，可以使用长命名法或特殊前缀解决，如果是引入的第三方库之间的命名冲突，可以使用link命令及flag解决冲突。 84.你实现过一个框架或者库以供别人使用么？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。 答： 抽象和封装，方便使用。 首先是对问题有充分的了解，比如构建一个文件解压压缩框架，从使用者的角度出发，只需关注发送给框架一个解压请求，框架完成复杂文件的解压操作，并且在适当的时候通知给使用者，如解压完成、解压出错等。在框架内部去构建对象的关系，通过抽象让其更为健壮、便于更改。其次是API的说明文档。 85.AFNetworking 底层原理分析 AFNetworking主要是对NSURLSession和NSURLConnection(iOS9.0废弃)的封装,其中主要有以下类: 1.AFHTTPRequestOperationManager：内部封装的是 NSURLConnection, 负责发送网络请求, 使用最多的一个类。(3.0废弃) 2.AFHTTPSessionManager：内部封装是 NSURLSession, 负责发送网络请求,使用最多的一个类 3.AFNetworkReachabilityManager：实时监测网络状态的工具类。当前的网络环境发生改变之后,这个工具类就可以检测到 4.AFSecurityPolicy：网络安全的工具类, 主要是针对 HTTPS 服务 5.AFURLRequestSerialization：序列化工具类,基类。上传的数据转换成JSON格式(AFJSONRequestSerializer).使用不多 6.AFURLResponseSerialization：反序列化工具类;基类.使用比较多: 7.AFJSONResponseSerializer; JSON解析器,默认的解析器. 8.AFHTTPResponseSerializer; 万能解析器; JSON和XML之外的数据类型,直接返回二进制数据.对服务器返回的数据不做任何处理. 9.AFXMLParserResponseSerializer; XML解析器; 86.描述下SDWebImage里面给UIImageView加载图片的逻辑 SDWebImage 中为 UIImageView 提供了一个分类UIImageView+WebCache.h, 这个分类中有一个最常用的接口sd_setImageWithURL:placeholderImage:，会在真实图片出现前会先显示占位图片，当真实图片被加载出来后再替换占位图片。 加载图片的过程大致如下： 1.首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以url 作为数据的索引先在内存中寻找是否有对应的缓存 2.如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据, 如果找到了, 就会把磁盘中的数据加载到内存中，并将图片显示出来 3.如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片 4.下载后的图片会加入缓存中，并写入磁盘中 5.整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来 SDWebImage原理： 调用类别的方法： 从内存（字典）中找图片（当这个图片在本次使用程序的过程中已经被加载过），找到直接使用。 从沙盒中找（当这个图片在之前使用程序的过程中被加载过），找到使用，缓存到内存中。 从网络上获取，使用，缓存到内存，缓存到沙盒。 SDWebImage内部实现过程 87.友盟统计接口统计的所有功能？ APP启动速度，APP停留页面时间等 其他知识点 1.HomeKit，是苹果2014年发布的智能家居平台。 2.什么是 OpenGL、Quartz 2D？ 答：Quatarz 2d 是Apple提供的基本图形工具库。只是适用于2D图形的绘制。 OpenGL，是一个跨平台的图形开发库。适用于2D和3D图形的绘制。 3.ffmpeg框架 答：ffmpeg 是音视频处理工具，既有音视频编码解码功能，又可以作为播放器使用。 4.谈谈 UITableView 的优化 答： 1). 正确的复用cell； 2). 设计统一规格的Cell； 3). 提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法； 4). 异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口； 5). 滑动时按需加载，这个在大量图片展示，网络加载的时候很管用！ 6). 减少子视图的层级关系； 7). 尽量使所有的视图不透明化以及做切圆操作； 8). 不要动态的add 或者 remove 子控件。最好在初始化时就添加完，然后通过hidden来控制是否显示； 9). 使用调试工具分析问题。 5.如何实行cell的动态的行高 答： 如果希望每条数据显示自身的行高，必须设置两个属性，1.预估行高，2.自定义行高。 设置预估行高 tableView.estimatedRowHeight = 200。 设置定义行高 tableView.estimatedRowHeight = UITableViewAutomaticDimension。 如果要让自定义行高有效，必须让容器视图有一个自下而上的约束。 6.说说你对 block 的理解 答：栈上的自动复制到堆上，block 的属性修饰符是 copy，循环引用的原理和解决方案。 block的循环引用；block的代码实现；为什么会造成循环引用；block是如何强引用self的； 7.什么是野指针、空指针？ 野指针： 不知道指向了哪里的指针叫野指针。即指针指向不确定，指针存的地址是一个垃圾值，未初始化。 空指针： 不指向任何位置的指针叫空指针。即指针没有指向，指针存的地址是一个空地址，NULL。 8.什么是 OOA / OOD / OOP ? OOA（Object Oriented Analysis） –面向对象分析 OOD（Object Oriented Design） –面向对象设计 OOP（Object Oriented Programming）–面向对象编程 9.在项目什么时候选择使用GCD，什么时候选择NSOperation? 项目中使用NSOperation的优点是NSOperation是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化NSOperation的设计思路，是具有面向对象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中使用。 项目中使用GCD的优点是GCD本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而Block参数的使用，会是代码更为易读，建议在简单项目中使用。 10.KVO，NSNotification，delegate及block区别 KVO就是cocoa框架实现的观察者模式，一般同KVC搭配使用，通过KVO可以监测一个值的变化，比如View的高度变化。是一对多的关系，一个值的变化会通知所有的观察者。 NSNotification是通知，也是一对多的使用场景。在某些情况下，KVO和NSNotification是一样的，都是状态变化之后告知对方。NSNotification的特点，就是需要被观察者先主动发出通知，然后观察者注册监听后再来进行响应，比KVO多了发送通知的一步，但是其优点是监听不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，使用也更灵活。 delegate 是代理，就是我不想做的事情交给别人做。比如狗需要吃饭，就通过delegate通知主人，主人就会给他做饭、盛饭、倒水，这些操作，这些狗都不需要关心，只需要调用delegate（代理人）就可以了，由其他类完成所需要的操作。所以delegate是一对一关系。 block是delegate的另一种形式，是函数式编程的一种形式。使用场景跟delegate一样，相比delegate更灵活，而且代理的实现更直观。 KVO一般的使用场景是数据，需求是数据变化，比如股票价格变化，我们一般使用KVO（观察者模式）。delegate一般的使用场景是行为，需求是需要别人帮我做一件事情，比如买卖股票，我们一般使用delegate。 Notification一般是进行全局通知，比如利好消息一出，通知大家去买入。delegate是强关联，就是委托和代理双方互相知道，你委托别人买股票你就需要知道经纪人，经纪人也不要知道自己的顾客。Notification是弱关联，利好消息发出，你不需要知道是谁发的也可以做出相应的反应，同理发消息的人也不需要知道接收的人也可以正常发出消息。 11.id和NSObject＊ 的区别 id是一个 objc_object 结构体指针，定义是 1 typedef struct objc_object *id id可以理解为指向对象的指针。所有oc的对象 id都可以指向，编译器不会做类型检查，id调用任何存在的方法都不会在编译阶段报错，当然如果这个id指向的对象没有这个方法，该崩溃还是会崩溃的。 NSObject *指向的必须是NSObject的子类，调用的也只能是NSObjec里面的方法否则就要做强制类型转换。 不是所有的OC对象都是NSObject的子类，还有一些继承自NSProxy。NSObject *可指向的类型是id的子集。 12.static关键字的作用 回答一： 1.在函数体内定义的static他的作用域为该函数体,该变量在内存中只被分配一次,因此,其值在下次调用时仍维持上次的值不变； 2.在模块内的static全局变量可以被模块内所有函数访问,但是不能被模块外的其他函数访问； 3.在模块内的staic全局变量可以被这一模块内的其他函数调用,这个函数的使用范围被限制在这个模块内; 4.在类中的static成员变量属于整个类所拥有,对类的所有对象只有一份拷贝,也就是说只要是该类的对象,那么该对象的中被static修饰的成员变量都指向同一块地址。 回答二：修饰局部变量： 1.延长局部变量的生命周期,程序结束才会销毁。 2.局部变量只会生成一份内存,只会初始化一次。 3.改变局部变量的作用域。修饰全局变量: 1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改 2.避免重复定义全局变量 在OC中static关键字使用误区 使用static修饰实例变量是不被允许的 2.使用static修饰了方法，也是错误的 13.使用 Swift 语言编程的优缺点 ? 答：总的来说，我认为使用 Swift 来作为编程语言的优点还是要远远大于缺点的，而且很多缺点苹果也在逐渐改善。 优点:1、简洁的语法2、更强的类型安全3、函数式编程的支持 Swift 语言本身提供了对函数式编程的支持。 Objc 本身是不支持的，但是可以通过引入 ReactiveCocoa 这个库来支持函数式编程。4、编写 OS X 下的自动化脚本 缺点:1、App体积变大 使用Swift 后， App 体积大概增加 5-8 M 左右，对体积大小敏感的慎用。 体积变大的原因是因为 Swift 还在变化，所以 Apple 没有在 iOS 系统里放入 Swift 的运行库，反而是每个 App 里都要包含其对应的 Swift 运行库。2、Xcode 支持不够好如果你是使用 Xcode经常卡住或者崩溃想必你是肯定碰到过了，这个是目前使用 Swift 最让人头疼的事情，即使是到现在XCode 9， 有时候也会遇到这种问题，所以要看你的承受力了……3、第三方库的支持不够多目前确实 Swift 编写的第三方库确实不多，但可以通过桥接的方式来使用 Objc 的三方库，基本上没有太大问题。现在已经改善很多了…4、语言版本更新带来的编译问题语言本身还在发展，所以每次版本更新后都会出现编译不过的情况（至少到目前为止还是），但是自从 4.0 版本发布后，改动没有 beta 时候那么大了，而且根据 Xcode 提示基本就可以解决语法变动导致的编译问题了。","categories":[{"name":"进阶","slug":"进阶","permalink":"http://yoursite.com/categories/进阶/"}],"tags":[{"name":"进阶","slug":"进阶","permalink":"http://yoursite.com/tags/进阶/"}],"keywords":[{"name":"进阶","slug":"进阶","permalink":"http://yoursite.com/categories/进阶/"}]},{"title":"Swift基础—集合类型","slug":"Swift基础—集合类型","date":"2019-04-26T14:07:06.000Z","updated":"2019-04-30T07:39:58.681Z","comments":true,"path":"2019/04/26/Swift基础—集合类型/","link":"","permalink":"http://yoursite.com/2019/04/26/Swift基础—集合类型/","excerpt":"","text":"1.数组 声明一个不可修改的数组12let num1 = [1,2,3]let num2 = [Int](repeating: 0, count: 5) 声明一个可以修改的数组 1var num3 = [3,1,2] 增加一个元素 1num3.append(4) 对原数组进行升序排序 1num3.sort() 对原数组进行降序排序 1num3.sort(by:&gt;) 将原数组除最后一个外的所有元素赋值给另一个数组 1let num4 = Array(num3[0..&lt;num3.count - 1]) 用数组实现栈123456789101112131415161718192021class Stack&#123;var stack: [AnyObject]var isEmpty: Bool&#123; return stack.isEmpty &#125;var peek: AnyObject? &#123; return stack.last &#125;init() &#123;stack = [AnyObject]()&#125;func push(object: AnyObject)&#123;stack.append(object)&#125;func pop() -&gt; AnyObject? &#123;if (!isEmpty) &#123;return stack.removeLast()&#125;else&#123;return nil&#125;&#125;&#125; 2.字典和集合12var primeNums: Set = [3, 5,7,11, 13]let oddNums: Set = [1, 3, 5, 7, 9] 交集、并集、差集 123let primeAndOddNum = primeNums.intersection(oddNums)let primeOrOddNum = primeNums.union(oddNums)let oddNumNotPrime = oddNums.subtracting(primeNums) 题目：给出一个整数型数组和一个目标值，判断数组中是否有两个数之和等于目标值。 123456789101112func twoSum(nums: [Int], _ target: Int) -&gt;Bool&#123;var set = Set&lt;Int&gt;()for num in nums &#123;if set.contains(target - num) &#123;return true&#125;set.insert(num)&#125;return false&#125; 题目改成：给定一个整数型数组中有且仅有两个数之和等于目标值，求这两个数在数组中的序号。 1234567891011121314func twoSum(nums: [Int], _ target:[Int] -&gt; [Int])&#123;var dict = [Int : Int]()for (i, num) in nums.enumerated() &#123;if let lastIndex = dict[target - num] &#123;return [lastIndex, i]&#125;else&#123;dict[num] = i&#125;&#125;fatalError(&quot;No valid output!&quot;)&#125; 3.字符串在Swift中，字符串不同于其他语言(包括OC),它是值类型，而非引用类型。 字符串和数字之间的转换 1234let str = &quot;3&quot;let num = Int(str)let number = 3let string = String(num) 字符串长度 1let len = str.count 访问字符串中的单个字符，时间复杂度为0（1） 1let char = str[str.index(str.startIndex, offsetBy: n)] 修改字符串 123str.remove(at: n)str.append(&quot;c&quot;)str += &quot;hello world&quot; 检测字符串是否由数字构成 123func isStrNum(str: String) -&gt; Bool&#123;return Int(str) != nil&#125; 将字符串数字按字母排序(不考虑大小写) 123func sortStr(str: String) -&gt; String&#123;return String(str.sorted())&#125; Google面试题：给出一个字符串，要求将其按照单词顺序进行反转。比如“the sky is blue”,反转后的结果是“blue is sky the”。思路：1.每个单词长度不一样；2.每个单词长度不一样。3.先实现一个字符串反转的方法 123456789101112fileprivate func _reverse&lt;T&gt;(_chars: inout [T], _ start: Int, _ end: Int)&#123;var start = start, end = endwhile start &lt; end &#123;_swap(&amp;chars, start, end)start += 1end -= 1&#125;&#125;fileprivate func swap&lt;T&gt;(_ chars: inout [T], _ p: Int, _ q: Int)&#123;(chars[p], chars[q], chars[p])&#125; 有了这个方法，就可以实现下面两种字符串的转换：1.整个字符串反转，“the sky is blue” -&gt; “eulb si yks eht”;2.每个单词作为一个字符串单独反转，“eulb si yks eht” -&gt; “blue is sky the”。 12345678910111213141516func reverseWords(s: String?) -&gt; String?&#123;guard let s = s else&#123;return nil&#125;var chars = Array(s.characters), start = 0_reverse(&amp;chars: 0, chars.count - 1)for i in 0..chars.count &#123;if i == chars.count - 1 || chars[i + 1] = &quot;&quot; &#123;_reverse(&amp;chars .start, i)start = i + 2&#125;&#125;return String(chars)&#125;","categories":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/tags/Swift/"}],"keywords":[{"name":"Swift","slug":"Swift","permalink":"http://yoursite.com/categories/Swift/"}]},{"title":"iOS开发体系","slug":"iOS开发体系","date":"2019-04-02T11:35:28.000Z","updated":"2019-04-30T07:38:31.046Z","comments":true,"path":"2019/04/02/iOS开发体系/","link":"","permalink":"http://yoursite.com/2019/04/02/iOS开发体系/","excerpt":"","text":"iOS开发体系 iOS 的知识体系，包括了基础、原理、应用开发、原生与前端四大模块。 基础模块iOS 开发者需要掌握的整个基础知识，按照 App 的开发流程进行了划分，如下图所示。 应用开发应用开发部分，需要关注一些经典的库。 原理模块iOS开发原理，主要是系统内核 XNU、AOP、内存管理和编译的知识。这些知识具有很强的通用性，其他任何语言、系统和领域都会涉及到。 原生与前端原生和前端部分，需要分析隐藏在这些技术背后的解释器和渲染技术，也正是这些技术造就了目前跨端方案的繁荣。从 H5 到 Flutter，渲染底层图形库都使用的是 Skia。也就是说，这么多年来渲染底层技术就基本没有变过。而且，向 Flutter 的演进也只是去掉了 H5 对低版本标准的支持。但，仅仅是去掉这些兼容代码，就使性能提升了数倍。 iOS知识体系整个专栏中涉及到的基础、原理、应用开发和原生与前端的知识，梳理到一起，就形成了如下图所示的 iOS 知识体系。","categories":[{"name":"进阶","slug":"进阶","permalink":"http://yoursite.com/categories/进阶/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}],"keywords":[{"name":"进阶","slug":"进阶","permalink":"http://yoursite.com/categories/进阶/"}]},{"title":"iOS-多线程","slug":"iOS-多线程","date":"2019-02-18T14:03:07.000Z","updated":"2019-04-30T06:36:33.933Z","comments":true,"path":"2019/02/18/iOS-多线程/","link":"","permalink":"http://yoursite.com/2019/02/18/iOS-多线程/","excerpt":"","text":"进程进程是指在系统中运行的一个程序 线程 1个进程要想执行任务必须得有线程(每个进程至少要有1条线程) 线程的串行一个线程中任务的执行时串行的,如果要在1个线程中执行多个任务,那么只能一个一个地按顺序执行这些任务.也就是说,在同一时间内,1个线程只能执行1个任务 进程和线程的比较1.线程是CPU调用(执行任务)的最小单位 2.进程是CPU分配资源和调度的单位 3.一个程序可以对应多个线程,一个进程中可以有多个线程,但至少要有一个线程 4.同一个进程内的线程共享进程的资源 多线程1个进程中可以开启多个线程每条线程可以并行(同时)执行不同的任务,多线程技术可以提高程序的执行效率 多线程原理同一时间,CPU只能处理1条线程,只有1条线程在工作(执行) 多线程并发(同时)执行,其实CPU快速地在多条线程之间调度(切换) 如果CPU调度线程的时间足够快,就造成了多线程并发执行的假象 注:单核CPU 多线程优缺点优点:能适当提高程序的执行效率 能适当提高资源利用(CPU 内存利用率) 缺点:创建线程是有开销的,iOS下主要成本包括:内核数据结构(大约1KB),栈控件(子线程512KB,主线程1M,也可以使用-setStackSize:设置,但必须是4K的倍数,而且最小是16K),创建线程大约需要90毫秒的创建时间 如果开启大量的线程,会降低程序的性能 线程越多,CPU在调度线程上的开销就越大 程序设计更加复杂:比如线程之间的通信,多线程的数据共享 主线程一个iOS程序运行后,默认会开启1条线程,称为”主线程”或”UI线程” 主线程的主要作用:1.显示\\刷新UI界面 2.处理UI事件(比如点击事件,滚动事件,拖拽事件等) ###主线程的使用注意:### 1.别将比较耗时的操作放到主线程(文件上传下载,多次循环) 2.耗时操作会卡主主线程,严重影响到UI的流畅度,给用户一种”卡”的怀体验 ###获取主线程、当前线程###12345678910111213141516//1.获取主线程NSThread *mainThread = [NSThread mainThread];NSLog(@&quot;%@&quot;,mainThread);//2.获取当前线程NSThread *currentThread = [NSThread currentThread];NSLog(@&quot;%@&quot;,currentThread);//3.判断主线程// 3.1 number == 1// 3.2 类方法BOOL isMainThreadA = [NSThread mainThread];// 3.3 对象方法BOOL isMainThreadB = [currentThread isMainThread];NSLog(@&quot;%zd----%zd&quot;,isMainThreadA,isMainThreadB); 1.Pthread的简单使用（了解）pthread是一套通用的多线程API适用于Unix、Linux、Windows等系统跨平台、可移植、使用难度大C语言、需要手动管理线程生命周期1234567891011121314151617181920- (void)viewDidLoad &#123;[super viewDidLoad];//1.创建线程对象pthread_t thread;//2.创建线程/*第一个参数:线程对象 传递地址第二个参数:线程的属性 NULL第三个参数:指向函数的指针第四个参数:函数需要接受的参数*/pthread_create(&amp;thread, NULL, task, NULL);&#125;void *task(void *param)&#123;NSLog(@&quot;%@-----&quot;,[NSThread currentThread]);return NULL;&#125; ##2.NSthread的基本使用##NSthread使用更加面向对象简单易用，可直接操作线程对象OC语言、需要手动管理线程生命周期 ####NSThread创建的第一种方法####需要手动启用线程1234567891011121314151617181920- (void)viewDidLoad &#123;[super viewDidLoad];//1.创建线程/*第一个参数:目标对象,self第二个参数:方法选择器,调用方法第三个参数:前面调用方法需要传递的参数 nil*/NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run:) object:@&quot;ABC&quot;];//2.启动线程[thread start];&#125;-(void)run:(NSString *)param&#123;NSLog(@&quot;----RUN----%@&quot;,[NSThread currentThread]);&#125; NSThread创建的第二种方法分离子线程，自动启动线程1234567891011- (void)viewDidLoad &#123;[super viewDidLoad];[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;分离子线程&quot;];&#125;-(void)run:(NSString *)param&#123;NSLog(@&quot;----RUN----%@&quot;,[NSThread currentThread]);&#125; NSThread创建的第三种方法开启一条后台线程1234567891011- (void)viewDidLoad &#123;[super viewDidLoad];[self performSelectorInBackground:@selector(run:) withObject:@&quot;开启后台线程&quot;];&#125;-(void)run:(NSString *)param&#123;NSLog(@&quot;----RUN----%@&quot;,[NSThread currentThread]);&#125; 第二、三种方法的优缺点：优点：简单快捷缺点：无法对线程进行更详细的设置 #####NSThread需要注意的属性方法#####123456789//设置线程名称@property (nullable, copy) NSString *name //设置线程优先级+ (double)threadPriority;//获得主线程+（NSThread *)mainThread;//是否为主线程-（BOOL）isMainThread; NSThread线程生命周期线程的生命周期：当任务执行完毕后被释放 NSThread线程状态(了解)12NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];[thread start]; 启动线程12- (void)start; // 进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态 阻塞（暂停）线程123+ (void)sleepUntilDate:(NSDate *)date;+ (void)sleepForTimeInterval:(NSTimeInterval)ti;// 进入阻塞状态 强制停止线程12+ (void)exit;// 进入死亡状态 注意：一旦线程停止（死亡）了，就不能再次开启任务 多线程的安全隐患以售票员买票为例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import &quot;ViewController.h&quot;@interface ViewController ()//售票员 A B C@property (nonatomic,strong) NSThread *threadA;@property (nonatomic,strong) NSThread *threadB;@property (nonatomic,strong) NSThread *threadC;//总票数@property (nonatomic,assign) NSInteger totalCount;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];self.totalCount = 100;self.threadA = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicket) object:nil];self.threadB = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicket) object:nil];self.threadC = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicket) object:nil];self.threadA.name = @&quot;售票员1&quot;;self.threadB.name = @&quot;售票员1&quot;;self.threadC.name = @&quot;售票员1&quot;;[self.threadA start];[self.threadB start];[self.threadC start];&#125;-(void)saleTicket&#123;while (1) &#123;//锁必须是全局唯一的//1.注意加锁的位置//2.注意枷锁的前提条件//3.注意枷锁是需要代价的,需要耗费性能//4.枷锁的结果:线程同步@synchronized(self)&#123;NSInteger count = self.totalCount;if (count &gt; 0) &#123;self.totalCount = count - 1;//卖出一张票NSLog(@&quot;%@卖出一张票,还剩%zd张票&quot;,[NSThread currentThread].name,self.totalCount);&#125;else&#123;NSLog(@&quot;票已售完,明天请早!&quot;);break;&#125;&#125;&#125;&#125;@end 互斥锁使用格式@synchronized(锁对象) { // 需要锁定的代码 }注意：锁定1份代码只用1把锁，用多把锁是无效的 互斥锁的优缺点优点：能有效防止因多线程抢夺资源造成的数据安全问题缺点：需要消耗大量的CPU资源 互斥锁的使用前提：多条线程抢夺同一块资源 相关专业术语：线程同步线程同步的意思是：多条线程在同一条线上执行（按顺序地执行任务）互斥锁，就是使用了线程同步技术 原子和非原子属性的选择nonatomic和atomic对比atomic：线程安全，需要消耗大量的资源nonatomic：非线程安全，适合内存小的移动设备 iOS开发的建议所有属性都声明为nonatomic尽量避免多线程抢夺同一块资源尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力 NSThread实现线程间通信什么叫做线程间通信？ 在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常- 进行通信 线程间通信的体现 1个线程传递数据给另1个线程 在1个线程中执行完特定任务后，转到另1个线程继续执行任务 线程间通信常用方法123- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait; 线程间通信示例 – 图片下载 1234567891011121314151617181920212223242526272829-(void)touchesBegan:(nonnull NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event&#123;// [self download2];//开启一条子线程来下载图片[NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];&#125;-(void)downloadImage&#123;//1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源NSURL *url = [NSURL URLWithString:@&quot;http://p6.qhimg.com/t01d2954e2799c461ab.jpg&quot;];//2.根据url地址下载图片数据到本地（二进制数据NSData *data = [NSData dataWithContentsOfURL:url];//3.把下载到本地的二进制数据转换成图片UIImage *image = [UIImage imageWithData:data];//4.回到主线程刷新UI//4.1 第一种方式// [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES];//4.2 第二种方式// [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES];//4.3 第三种方式[self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES];&#125; 如何计算代码段的执行时间12345678910111213//第一种方法NSDate *start = [NSDate date];//2.根据url地址下载图片数据到本地（二进制数据）NSData *data = [NSData dataWithContentsOfURL:url];NSDate *end = [NSDate date];NSLog(@&quot;第二步操作花费的时间为%f&quot;,[end timeIntervalSinceDate:start]);//第二种方法CFTimeInterval start = CFAbsoluteTimeGetCurrent();NSData *data = [NSData dataWithContentsOfURL:url];CFTimeInterval end = CFAbsoluteTimeGetCurrent();NSLog(@&quot;第二步操作花费的时间为%f&quot;,end - start); 3.GCD的使用什么是GCD? 全称是Grand Central Dispatch，可译为“牛逼的中枢调度器” 纯C语言，提供了非常多强大的函数 GCD的优势 GCD是苹果公司为多核的并行运算提出的解决方案 GCD会自动利用更多的CPU内核（比如双核、四核） GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程） 程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码 GCD中有2个核心概念 任务：执行什么操作 队列：用来存放任务 GCD的使用就2个步骤 定制任务确定想做的事情 将任务添加到队列中GCD会自动将队列中的任务取出，放到对应的线程中执行任务的取出遵循队列的FIFO原则：先进先出，后进后出 执行任务GCD中有2个用来执行任务的常用函数1.用同步的方式执行任务123dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);queue：队列block：任务 2.用异步的方式执行任务1dispatch_async(dispatch_queue_t queue, dispatch_block_t block); 同步和异步的区别 同步：只能在当前线程中执行任务，不具备开启新线程的能力 异步：可以在新的线程中执行任务，具备开启新线程的能力 GCD中还有个用来执行任务的函数（栅栏函数)：1dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block); 在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行- 这个queue不能是全局的并发队列 队列的类型 GCD的队列可以分为2大类型 并发队列（Concurrent Dispatch Queue）可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）并发功能只有在异步（dispatch_async）函数下才有效 串行队列（Serial Dispatch Queue）让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务） 容易混淆的术语有4个术语比较容易混淆：_同步_、_异步_、_并发_、_串行_同步和异步主要影响：能不能开启新的线程同步：只是在_当前_线程中执行任务，不具备开启新线程的能力异步：可以在_新的_线程中执行任务，_具备_开启新线程的能力 并发和串行主要影响：任务的执行方式并发：允许_多个_任务并发（同时）执行_串行_：_一个_任务执行完毕后，再执行下一个任务 并发队列 使用dispatch_queue_create函数创建队列 123dispatch_queue_tdispatch_queue_create(const char *label, // 队列名称 dispatch_queue_attr_t attr); // 队列的类型 创建并发队列 1dispatch_queue_t queue = dispatch_queue_create(&quot;com.520it.queue&quot;, DISPATCH_QUEUE_CONCURRENT); GCD默认已经提供了全局的并发队列，供整个应用使用，可以无需手动创建使用dispatch_get_global_queue函数获得全局的并发队列 123dispatch_queue_t dispatch_get_global_queue(dispatch_queue_priority_t priority, // 队列的优先级unsigned long flags); // 此参数暂时无用，用0即可 获得全局并发队列 1dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 全局并发队列的优先级 1234#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台 串行队列 GCD中获得串行有2种途径使用dispatch_queue_create函数创建串行队列12// 创建串行队列（队列类型传递NULL或者DISPATCH_QUEUE_SERIAL）dispatch_queue_t queue = dispatch_queue_create(&quot;com.520it.queue&quot;, NULL); 使用主队列（跟主线程相关联的队列）1.主队列是GCD自带的一种特殊的串行队列2.放在主队列中的任务，都会放到主线程中执行3.使用dispatch_get_main_queue()获得主队列1dispatch_queue_t queue = dispatch_get_main_queue(); 各种队列的执行效果 GCD线程间通信 从子线程回到主线程1234567dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;// 执行耗时的异步操作...dispatch_async(dispatch_get_main_queue(), ^&#123;// 回到主线程，执行UI刷新操作&#125;);&#125;); 延时执行iOS常见的延时执行 1.调用NSObject的方法 12[self performSelector:@selector(run) withObject:nil afterDelay:2.0];// 2秒后再调用self的run方法 2.使用GCD函数 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;// 2秒后执行这里的代码...&#125;); 3.使用NSTimer 1[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:NO]; 一次性代码 使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次 不可以放在懒加载中执行1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;// 只执行1次的代码(这里面默认是线程安全的)&#125;); 快速迭代 使用dispatch_apply函数能进行快速迭代遍历123456//第一个参数：遍历的次数//第二个参数：队列(并发队列)，不可以传主队列会造成死锁；不可以传串行队列，没有任何作用//第三个参数：index 索引dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t index)&#123;// 执行10次代码，index顺序不确定&#125;); 队列组 有这么1种需求1.分别异步执行2个耗时的操作2.等2个异步操作都执行完毕后，再回到主线程执行操作 如果想要快速高效地实现上述需求，可以考虑用队列组1234567891011121314dispatch_group_t group = dispatch_group_create();//1.封装任务//2.把任务添加到队列中//3.会监听任务的执行情况，通知groupdispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;// 执行1个耗时的异步操作&#125;);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;// 执行1个耗时的异步操作&#125;);//拦截通知，当队列组中所有的任务都执行完毕的时候会进入到下面的方法dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;// 等前面的异步操作都执行完毕后，回到主线程...&#125;); 3.NSOperation的使用 NSOperation的作用配合使用NSOperation和NSOperationQueue也能实现多线程编程 NSOperation和NSOperationQueue实现多线程的具体步骤1.先将需要执行的操作封装到一个NSOperation对象中2.然后将NSOperation对象添加到NSOperationQueue中3.系统会自动将NSOperationQueue中的NSOperation取出来4.将取出的NSOperation封装的操作放到一条新线程中执行 #####NSOperation的子类##### NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类 使用NSOperation子类的方式有3种1.NSInvocationOperation2.NSBlockOperation3.自定义子类继承NSOperation，实现内部相应的方法 NSInvocationOperation 创建NSInvocationOperation对象 12345- (id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;调用start方法开始执行操作- (void)start;一旦执行操作，就会调用target的sel方法 注意1.默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作2.只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作 #####NSBlockOperation##### 创建NSBlockOperation对象 1+ (id)blockOperationWithBlock:(void (^)(void))block; 通过addExecutionBlock:方法添加更多的操作 1- (void)addExecutionBlock:(void (^)(void))block; 注意：只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作 NSOperationQueue NSOperationQueue的作用1.NSOperation可以调用start方法来执行任务，但默认是同步执行的2.如果将NSOperation添加到NSOperationQueue（操作队列）中，系统会自动异步执行NSOperation中的操作 添加操作到NSOperationQueue中 12- (void)addOperation:(NSOperation *)op;- (void)addOperationWithBlock:(void (^)(void))block; #####自定义NSOperation##### 自定义NSOperation的步骤很简单重写- (void)main方法，在里面实现想执行的任务 重写- (void)main方法的注意点自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）经常通过- (BOOL)isCancelled方法检测操作是否被取消，对取消做出响应 最大并发数 什么是并发数同时执行的任务数比如，同时开3个线程执行3个任务，并发数就是3 最大并发数的相关方法 12345678- (NSInteger)maxConcurrentOperationCount;- (void)setMaxConcurrentOperationCount:(NSInteger)cnt;//串行执行任务不等于只开一条线程(编程同步)maxConcurrentOperationCount &gt; 1 并发队列maxConcurrentOperationCount == 1 串行队列maxConcurrentOperationCount == 0 不会执行任务maxConcurrentOperationCount == -1 特殊意义 最大值 表示不受限制 队列的取消、暂停、恢复 取消队列的所有操作 123//取消不可以恢复- (void)cancelAllOperations;//提示：也可以调用NSOperation的- (void)cancel方法取消单个操作 暂停和恢复队列 1234//暂停是可以恢复//不能暂停当前正在处于执行状态的任务- (void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列- (BOOL)isSuspended; 操作依赖 NSOperation之间可以设置依赖来保证执行顺序比如一定要让操作A执行完后，才能执行操作B，可以这么写 1[operationB addDependency:operationA]; // 操作B依赖于操作A 可以在不同queue的NSOperation之间创建依赖关系 操作的监听 可以监听一个操作的执行完毕12- (void (^)(void))completionBlock;- (void)setCompletionBlock:(void (^)(void))block; NSOperation实现线程间通信12345678910111213141516171819202122232425262728-(void)download&#123;//http://s15.sinaimg.cn/bmiddle/4c0b78455061c1b7f1d0e//1.开子线程下载图片//1.1 非主队列NSOperationQueue *queue = [[NSOperationQueue alloc]init];//1.2 封装操作NSBlockOperation *download = [NSBlockOperation blockOperationWithBlock:^&#123;NSURL *url = [NSURL URLWithString:@&quot;http://s15.sinaimg.cn/bmiddle/4c0b78455061c1b7f1d0e&quot;];NSData *imageData = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:imageData];NSLog(@&quot;download---%@&quot;,[NSThread currentThread]);//3.回到主线程、更新UI[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;self.imageView.image = image;NSLog(@&quot;UI---%@&quot;,[NSThread currentThread]);&#125;];&#125;];//2.添加操作到队列[queue addOperation:download];&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}],"keywords":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}]},{"title":"iOS-Block","slug":"iOS-Block","date":"2019-01-26T12:17:13.000Z","updated":"2019-04-30T06:16:59.994Z","comments":true,"path":"2019/01/26/iOS-Block/","link":"","permalink":"http://yoursite.com/2019/01/26/iOS-Block/","excerpt":"","text":"1.block概述 Block是一种特殊的数据类型,其可以正常定义变量、作为参数、作为返回值,特殊地,Block还可以保存一段代码,在需要的时候调用,目前Block已经广泛应用于iOS开发中,常用于GCD、动画、排序及各类回调。 2.block作用 保存一段代码 3.block声明12//block声明: 返回值(^block变量名)(参数)void(^block)(); 4.block定义12345678910111213141516//block定义:3种方式 ==&gt; ^(参数)&#123;&#125;//1.void(^block1)() = ^()&#123;&#125;;//2.如果没有参数,参数可以隐藏. 如果有参数,定义的时候必须写参数,而且必须要有参数变量名void(^block2)(int) = ^(int a)&#123;&#125;;//3.block返回可以省略,不管有没有返回值都可以省略int(^block3)() = ^int&#123;return 3;&#125;; 5.block类型NSGlobalBlock （NSConcreteGlobalBlock）NSStackBlock （NSConcreteStackBlock）NSMallocBlock （__NSConcreteMallocBlock） 1.NSGlobalBlock12345void(^block)(void) = ^(void) &#123; &#125;;block();NSLog(@&quot;%@&quot;,block); 控制台打印： 2018-08-04 13:49:15.074751+0800 Block[32487:7895146] &lt;NSGlobalBlock: 0x1071e8088&gt; 2.NSMallocBlock123456int a = 10;void(^block)(void) = ^(void) &#123;NSLog(@&quot;%d&quot;,a);&#125;;block();NSLog(@&quot;%@&quot;,block); 控制台打印： 2018-08-04 13:53:49.489064+0800 Block[32567:7900709] 102018-08-04 13:53:49.489328+0800 Block[32567:7900709] &lt;NSMallocBlock: 0x60000025e870&gt; 3. NSStackBlock123456789101112131415161718192021int a = 10;void(^block)(void) = ^(void) &#123;// NSLog(@&quot;%d&quot;,a);&#125;;block();// NSLog(@&quot;%@&quot;,block);NSLog(@&quot;%@&quot;,^(void) &#123;NSLog(@&quot;%d&quot;,a);&#125;);``` **控制台打印：**&gt;2018-08-04 14:00:38.216673+0800 Block[32615:7906112] &lt;__NSStackBlock__: 0x7ffeeb385b38&gt;***### 6\\.block使用场景#### ①保存代码**1\\.在一个方法中定义，在另一个方法中调用**注：基本不用，有点多此一举 #import “ViewController.h” @interface ViewController () //block怎么声明,就如何定义成属性@property (nonatomic,strong) void(^block)(); @end @implementation ViewController (void)viewDidLoad {[super viewDidLoad]; void(^block)() = ^{NSLog(@”调用了block”);};_block = block; } -(void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event{_block();} @end123**2.在一个类中定义，在另一个类中调用**需求：1.tableview展示3个cell，打电话、发短信、发邮件- **cellItem.h** #import &lt;Foundation/Foundation.h&gt; @interface cellItem : NSObject//设计模型:控件需要展示什么内容,就定义什么属性@property (nonatomic,strong) NSString *title; //保存每个cell做的事情@property (nonatomic,strong) void(^block)(); +(instancetype)itemWitTitle:(NSString *)title; @end 1- **cellItem.m** #import “cellItem.h” @implementation cellItem +(instancetype)itemWitTitle:(NSString )title{cellItem item = [[self alloc]init];item.title = title;return item;}@end1- **JKYTableViewController.m** #import “JKYTableViewController.h” #import “cellItem.h” @interface JKYTableViewController () @property (nonatomic,strong) NSArray *items; @end @implementation JKYTableViewController (void)viewDidLoad {[super viewDidLoad];cellItem item1 = [cellItem itemWitTitle:@”打电话”];cellItem item2 = [cellItem itemWitTitle:@”发短信”];cellItem *item3 = [cellItem itemWitTitle:@”发邮件”];_items = @[item1,item2,item3]; //block保存代码item1.block = ^{NSLog(@”打电话”);};item2.block = ^{NSLog(@”发短信”);};item3.block = ^{NSLog(@”发邮件”);};} -(NSInteger)numberOfSectionsInTableView:(UITableView )tableView{return _items.count;}-(UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath )indexPath{static NSString ID = @”cell”;UITableViewCell cell = [tableView dequeueReusableCellWithIdentifier:ID];if (cell == nil) {cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:ID];} cellItem *item = self.items[indexPath.row];cell.textLabel.text = item.title; return cell;} -(void)tableView:(UITableView )tableView didSelectRowAtIndexPath:(NSIndexPath )indexPath{cellItem *item = self.items[indexPath.row];if (item.block) {item.block();}}@end 12345#### ②代理传值**需求：** 点击viewController跳转到modalViewController，再将字符串@&quot;123&quot;反向传值给ViewController- **modalViewController.h** #import &lt;UIKit/UIKit.h&gt; @interface modalViewController : UIViewController@property (nonatomic,strong) void(^block)(NSString *value); @end1- **modalViewController.m** #import “modalViewController.h” @interface modalViewController () @end @implementation modalViewController (void)viewDidLoad {[super viewDidLoad];// Do any additional setup after loading the view.} -(void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event{//传值给ViewController//@”123” if (_block) {_block(@”123”);}} @end 1- ** ViewController.m** #import “ViewController.h” #import “modalViewController.h”/**传值:1.只要拿到对方就能传值 顺传:给需要传值的对象,直接定义属性就能传值逆传:用代理,block,就是用block去代替代理 */ @interface ViewController () @end @implementation ViewController -(void)touchesBegan:(NSSet )touches withEvent:(UIEvent )event{modalViewController *modalVC = [[modalViewController alloc]init];modalVC.view.backgroundColor = [UIColor cyanColor]; //modalVC.block = ^(NSString *value) {NSLog(@”%@--%@”,[self class],value);}; [self presentViewController:modalVC animated:YES completion:nil];} (void)viewDidLoad {[super viewDidLoad];}@end123456789101112- **控制台打印：**&gt;2018-08-04 19:09:31.114136+0800 block代理传值[33591:8085166] ViewController--123#### ③参数使用- **总结**1\\.怎么区分参数是block,就看有没有^,只要有^,就把block当做参数2\\.把block当做参数,并不是马上调用block,什么时候调用由方法内部决定3\\.什么时候把block当做参数使用:做的事情由外界决定,但是什么时候做由内部决定**需求：**封装一个计算器,提供一个计算方法,怎么计算由外界决定,什么时候计算由内部决定- **CalculateManager.h** #import &lt;Foundation/Foundation.h&gt; @interface CalculateManager : NSObject @property (nonatomic,assign) NSInteger result;//计算-(void)calculate:(NSInteger(^)(NSInteger result))calculateBlock; @end1- **CalculateManager.m** #import “CalculateManager.h” @implementation CalculateManager -(void)calculate:(NSInteger (^)(NSInteger))calculateBlock{if (calculateBlock) {_result = calculateBlock(_result);}} @end1- **ViewController.m** #import “ViewController.h” #import “CalculateManager.h” @interface ViewController () @end @implementation ViewController (void)viewDidLoad {[super viewDidLoad]; // [UIView animateWithDuration:0 animations:^{// }]; CalculateManager manageer = [[CalculateManager alloc]init];[manageer calculate:^NSInteger(NSInteger result) {result += 5;result += 6;result = 2;return result;}]; NSLog(@”%ld”,manageer.result); }@end1234#### ④返回值block返回值常见于框架中，如：masonry中常见的链式编程，把所有的语句用**.**号连接起来。好处，可读性强 #import “ViewController.h” @interface ViewController () @end @implementation ViewController (void)viewDidLoad {[super viewDidLoad]; // make.center.equalTo(ws.view);self.test();} -(void(^)())test{NSLog(@”%s”,func);// void(^block)() = ^{//// };// return block; return ^{ NSLog(@”调用了block”); }; } 12**需求：**封装一个计算器,提供一个加号方法- **CalculateManager.h** #import &lt;Foundation/Foundation.h&gt; @interface CalculateManager : NSObject @property (nonatomic,assign) NSInteger reslt; //-(CalculateManager )add:(NSInteger)value;-(CalculateManager (^)(NSInteger))add; @end 1- **CalculateManager.m** #import “CalculateManager.h” @implementation CalculateManager //-(CalculateManager *)add:(NSInteger)value//{// _reslt += value;// return self;//} -(CalculateManager *(^)(NSInteger))add{return ^(NSInteger value){ _reslt += value;return self;};} @end 1- **ViewController.m** #import “ViewController.h” #import “CalculateManager.h” @interface ViewController () @end @implementation ViewController (void)viewDidLoad {[super viewDidLoad]; CalculateManager *manager = [[CalculateManager alloc]init];// [[[manager add:5]add:6]add:7];manager.add(5).add(10).add(20);NSLog(@”%ld”,manager.reslt); } @end 1234567891011121314***### 7\\.block内存管理- **block是不是一个对象**查阅苹果官方文档，Block是一个Objective-C对象。Blocks are Objective-C objects。#### MRC引申**如何判断当前文件是ARC还是MRC？**1.dealloc 能否调用super，只有MRC才能调用super2.能否使用retain，release，如果能用就是MRC -(void)dealloc{[super dealloc];}//ARC环境下报错，ARC forbids explicit message send of ‘dealloc’123456789101112131415161718192021- **MRC了解常识：**1.MRC没有strong、weak、局部变量对象2.MRC给成员属性赋值，一定要使用set方法，不能直接访问下划线成员属性赋值- **MRC：管理block**⭐️⭐️⭐️1\\.只要block没有引用外部局部变量，block放在全局区2\\.只要block引用外部局部变量，block放在栈里面3\\.blcok只能使用copy，不能使用retain，使用retain，block还是在栈里面***#### ARC- **ARC管理原则：**只要有一个对象没有被强指针修饰就会被销毁，默认局部变量对象都是强指针，存放到堆里面- **ARC：管理block**⭐️⭐️⭐️1\\.只要block引用外部局部变量，block放在堆里面2\\.block使用strong，最好不要使用copy***### 8\\.block循环引用 (void)viewDidLoad {[super viewDidLoad]; //block造成循环引用:Block会对里面所有外部变量对象全部强引用 __weak typeof(self) weakSelf = self;_block = ^{NSLog(@”%@”,weakSelf); __strong typeof(weakSelf) strongSelf = weakSelf; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@”%@”,strongSelf);}); }; _block();} 123456### 9\\.block变量传递- **总结**1\\.如果是局部变量，block是值传递2\\.如果是静态变量、全局变量、__block修饰的变量，block都是指针传递 (void)viewDidLoad {[super viewDidLoad]; //1.static int a = 3;//2.int a = 3;void(^block)() = ^() {NSLog(@”%d”,a);}; a = 5; block();}`控制台：1.static int a = 3; 2018-08-04 21:21:24.733048+0800 block变量传递[34240:8168797] 5 2.int a = 3; 2018-08-04 21:22:26.695827+0800 block变量传递[34254:8170195] 3","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"Block","slug":"Block","permalink":"http://yoursite.com/tags/Block/"}],"keywords":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}]},{"title":"iOS-多图下载","slug":"iOS-多图下载","date":"2019-01-05T12:01:34.000Z","updated":"2019-04-30T06:10:25.216Z","comments":true,"path":"2019/01/05/iOS-多图下载/","link":"","permalink":"http://yoursite.com/2019/01/05/iOS-多图下载/","excerpt":"","text":"1.iOS多图下载的缓存处理 需求在tableview的每一个cell里显示从网络下载的图片 Demo12345678910111213141516171819202122232425262728-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;static NSString *ID = @&quot;app&quot;;//1.创建cellUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];//2.设置cell数据//2.1拿到该行cell对应的数据JKYApp *appM = self.apps[indexPath.row];cell.textLabel.text = appM.name;cell.detailTextLabel.text = appM.download;//设置图标UIImage *image = [self.imageDic objectForKey:appM.icon];if (image) &#123;cell.imageView.image = image;&#125;else&#123;NSURL *url = [NSURL URLWithString:appM.icon];NSData *imageData = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:imageData];cell.imageView.image = image;//将图片保存到内存缓存[self.imageDic setObject:image forKey:appM.icon];&#125;//3.返回cellreturn cell;&#125; 2.造成的问题 1.UI不流畅dataWithContentsOfURL：是耗时操作，将其放在主线程会造成卡顿。如果图片很多，图片很大，而且网络情况不好的话会造成用户体验极差 2.图片重复下载由于没有缓存机制，即使下载完成并显示了当前cell的图片，但是当该cell再一次滚动，显示的时候还是会下载它所对应的图片，耗费了下载流量，而且还导致重复操作。 3.解决方案 注: 原图是大神J_Knight_文章里下载的，还有下面这一节内容也是来源于J_Knight_老师，觉得挺好的就拿过来知识点复习汇总了，如有冒犯必定立即删除。 图片的URL：因为每张图片对应的URL都是唯一的，所以我们可以通过它来建立图片缓存和下载操作的缓存的键，以及拼接沙盒缓存的路径字符串。 图片缓存（字典）：存放于内存中；键为图片的URL，值为UIImage对象。作用：读取速度快，直接使用UIImage对象。 下载操作缓存（字典）：存放与内存中，键为图片的URL，值为NSBlockOperation对象。作用：用来避免对于同一张图片还要开启多个下载线程。 沙盒缓存(文件路径对应NSData)：存放于磁盘中，位于Cache文件夹内，路径为“Cache/图片URL的最后的部分”，值为NSData对象（将UIImage转化为NSData才能写入磁盘里）。作用：程序断网，再次启动也可以直接在磁盘中拿到图片。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//先去查看内存缓存中该图片时候已经存在,如果存在那么久直接拿来用,否则去检查磁盘缓存//如果有磁盘缓存,那么保存一份到内存,设置图片,否则就直接下载//1)没有下载过//2)重新打开程序UIImage *image = [self.images objectForKey:appM.icon];if (image) &#123;cell.imageView.image = image;NSLog(@&quot;%zd处的图片使用了内存缓存中的图片&quot;,indexPath.row) ;&#125;else&#123;//保存图片到沙盒缓存NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];//获得图片的名称,不能包含/NSString *fileName = [appM.icon lastPathComponent];//拼接图片的全路径NSString *fullPath = [caches stringByAppendingPathComponent:fileName];//检查磁盘缓存NSData *imageData = [NSData dataWithContentsOfFile:fullPath];//废除imageData = nil;if (imageData) &#123;UIImage *image = [UIImage imageWithData:imageData];cell.imageView.image = image;NSLog(@&quot;%zd处的图片使用了磁盘缓存中的图片&quot;,indexPath.row) ;//把图片保存到内存缓存[self.images setObject:image forKey:appM.icon];// NSLog(@&quot;%@&quot;,fullPath);&#125;else&#123;//检查该图片时候正在下载,如果是那么久什么都捕捉,否则再添加下载任务NSBlockOperation *download = [self.operations objectForKey:appM.icon];if (download) &#123;&#125;else&#123;//先清空cell原来的图片cell.imageView.image = [UIImage imageNamed:@&quot;Snip20160221_306&quot;];download = [NSBlockOperation blockOperationWithBlock:^&#123;NSURL *url = [NSURL URLWithString:appM.icon];NSData *imageData = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:imageData];NSLog(@&quot;%zd--下载---&quot;,indexPath.row);//容错处理if (image == nil) &#123;[self.operations removeObjectForKey:appM.icon];return ;&#125;//演示网速慢的情况//[NSThread sleepForTimeInterval:3.0];//把图片保存到内存缓存[self.images setObject:image forKey:appM.icon];//NSLog(@&quot;Download---%@&quot;,[NSThread currentThread]);//线程间通信[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;//cell.imageView.image = image;//刷新一行[self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationLeft];//NSLog(@&quot;UI---%@&quot;,[NSThread currentThread]);&#125;];//写数据到沙盒[imageData writeToFile:fullPath atomically:YES];//移除图片的下载操作[self.operations removeObjectForKey:appM.icon];&#125;];//添加操作到操作缓存中[self.operations setObject:download forKey:appM.icon];//添加操作到队列中[self.queue addOperation:download];&#125; &#125;&#125;//3.返回cellreturn cell; 4.内存警告处理1234567-(void)didReceiveMemoryWarning&#123;[self.images removeAllObjects];//取消队列中所有的操作[self.queue cancelAllOperations];&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}],"keywords":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}]}]}