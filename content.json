{"meta":{"title":"小金渣blog","subtitle":null,"description":null,"author":"小金渣","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"iOS-多图下载","slug":"iOS-多图下载","date":"2019-04-30T05:38:47.000Z","updated":"2019-04-30T05:38:47.360Z","comments":true,"path":"2019/04/30/iOS-多图下载/","link":"","permalink":"http://yoursite.com/2019/04/30/iOS-多图下载/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"iOS-多图下载","slug":"测试","date":"2019-01-05T12:01:34.000Z","updated":"2019-04-30T05:40:21.021Z","comments":true,"path":"2019/01/05/测试/","link":"","permalink":"http://yoursite.com/2019/01/05/测试/","excerpt":"","text":"1.iOS多图下载的缓存处理 需求在tableview的每一个cell里显示从网络下载的图片 Demo12345678910111213141516171819202122232425262728-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;static NSString *ID = @&quot;app&quot;;//1.创建cellUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];//2.设置cell数据//2.1拿到该行cell对应的数据JKYApp *appM = self.apps[indexPath.row];cell.textLabel.text = appM.name;cell.detailTextLabel.text = appM.download;//设置图标UIImage *image = [self.imageDic objectForKey:appM.icon];if (image) &#123;cell.imageView.image = image;&#125;else&#123;NSURL *url = [NSURL URLWithString:appM.icon];NSData *imageData = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:imageData];cell.imageView.image = image;//将图片保存到内存缓存[self.imageDic setObject:image forKey:appM.icon];&#125;//3.返回cellreturn cell;&#125; 2.造成的问题 1.UI不流畅dataWithContentsOfURL：是耗时操作，将其放在主线程会造成卡顿。如果图片很多，图片很大，而且网络情况不好的话会造成用户体验极差 2.图片重复下载由于没有缓存机制，即使下载完成并显示了当前cell的图片，但是当该cell再一次滚动，显示的时候还是会下载它所对应的图片，耗费了下载流量，而且还导致重复操作。 3.解决方案 注: 原图是大神J_Knight_文章里下载的，还有下面这一节内容也是来源于J_Knight_老师，觉得挺好的就拿过来知识点复习汇总了，如有冒犯必定立即删除。 图片的URL：因为每张图片对应的URL都是唯一的，所以我们可以通过它来建立图片缓存和下载操作的缓存的键，以及拼接沙盒缓存的路径字符串。 图片缓存（字典）：存放于内存中；键为图片的URL，值为UIImage对象。作用：读取速度快，直接使用UIImage对象。 下载操作缓存（字典）：存放与内存中，键为图片的URL，值为NSBlockOperation对象。作用：用来避免对于同一张图片还要开启多个下载线程。 沙盒缓存(文件路径对应NSData)：存放于磁盘中，位于Cache文件夹内，路径为“Cache/图片URL的最后的部分”，值为NSData对象（将UIImage转化为NSData才能写入磁盘里）。作用：程序断网，再次启动也可以直接在磁盘中拿到图片。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//先去查看内存缓存中该图片时候已经存在,如果存在那么久直接拿来用,否则去检查磁盘缓存//如果有磁盘缓存,那么保存一份到内存,设置图片,否则就直接下载//1)没有下载过//2)重新打开程序UIImage *image = [self.images objectForKey:appM.icon];if (image) &#123;cell.imageView.image = image;NSLog(@&quot;%zd处的图片使用了内存缓存中的图片&quot;,indexPath.row) ;&#125;else&#123;//保存图片到沙盒缓存NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];//获得图片的名称,不能包含/NSString *fileName = [appM.icon lastPathComponent];//拼接图片的全路径NSString *fullPath = [caches stringByAppendingPathComponent:fileName];//检查磁盘缓存NSData *imageData = [NSData dataWithContentsOfFile:fullPath];//废除imageData = nil;if (imageData) &#123;UIImage *image = [UIImage imageWithData:imageData];cell.imageView.image = image;NSLog(@&quot;%zd处的图片使用了磁盘缓存中的图片&quot;,indexPath.row) ;//把图片保存到内存缓存[self.images setObject:image forKey:appM.icon];// NSLog(@&quot;%@&quot;,fullPath);&#125;else&#123;//检查该图片时候正在下载,如果是那么久什么都捕捉,否则再添加下载任务NSBlockOperation *download = [self.operations objectForKey:appM.icon];if (download) &#123;&#125;else&#123;//先清空cell原来的图片cell.imageView.image = [UIImage imageNamed:@&quot;Snip20160221_306&quot;];download = [NSBlockOperation blockOperationWithBlock:^&#123;NSURL *url = [NSURL URLWithString:appM.icon];NSData *imageData = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:imageData];NSLog(@&quot;%zd--下载---&quot;,indexPath.row);//容错处理if (image == nil) &#123;[self.operations removeObjectForKey:appM.icon];return ;&#125;//演示网速慢的情况//[NSThread sleepForTimeInterval:3.0];//把图片保存到内存缓存[self.images setObject:image forKey:appM.icon];//NSLog(@&quot;Download---%@&quot;,[NSThread currentThread]);//线程间通信[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;//cell.imageView.image = image;//刷新一行[self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationLeft];//NSLog(@&quot;UI---%@&quot;,[NSThread currentThread]);&#125;];//写数据到沙盒[imageData writeToFile:fullPath atomically:YES];//移除图片的下载操作[self.operations removeObjectForKey:appM.icon];&#125;];//添加操作到操作缓存中[self.operations setObject:download forKey:appM.icon];//添加操作到队列中[self.queue addOperation:download]; &#125; &#125;&#125;//3.返回cellreturn cell; 4.内存警告处理1234567-(void)didReceiveMemoryWarning&#123;[self.images removeAllObjects];//取消队列中所有的操作[self.queue cancelAllOperations];&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}],"keywords":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}]}]}