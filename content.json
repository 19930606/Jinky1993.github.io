{"meta":{"title":"小金渣blog","subtitle":null,"description":null,"author":"小金渣","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"iOS-多图下载","slug":"iOS-多图下载","date":"2019-04-30T05:38:47.000Z","updated":"2019-04-30T05:43:48.486Z","comments":true,"path":"2019/04/30/iOS-多图下载/","link":"","permalink":"http://yoursite.com/2019/04/30/iOS-多图下载/","excerpt":"","text":"1.iOS多图下载的缓存处理 需求在tableview的每一个cell里显示从网络下载的图片 Demo12345678910111213141516171819202122232425262728-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;static NSString *ID = @&quot;app&quot;;//1.创建cellUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];//2.设置cell数据//2.1拿到该行cell对应的数据JKYApp *appM = self.apps[indexPath.row];cell.textLabel.text = appM.name;cell.detailTextLabel.text = appM.download;//设置图标UIImage *image = [self.imageDic objectForKey:appM.icon];if (image) &#123;cell.imageView.image = image;&#125;else&#123;NSURL *url = [NSURL URLWithString:appM.icon];NSData *imageData = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:imageData];cell.imageView.image = image;//将图片保存到内存缓存[self.imageDic setObject:image forKey:appM.icon];&#125;//3.返回cellreturn cell;&#125; 2.造成的问题 1.UI不流畅dataWithContentsOfURL：是耗时操作，将其放在主线程会造成卡顿。如果图片很多，图片很大，而且网络情况不好的话会造成用户体验极差 2.图片重复下载由于没有缓存机制，即使下载完成并显示了当前cell的图片，但是当该cell再一次滚动，显示的时候还是会下载它所对应的图片，耗费了下载流量，而且还导致重复操作。 3.解决方案 注: 原图是大神J_Knight_文章里下载的，还有下面这一节内容也是来源于J_Knight_老师，觉得挺好的就拿过来知识点复习汇总了，如有冒犯必定立即删除。 图片的URL：因为每张图片对应的URL都是唯一的，所以我们可以通过它来建立图片缓存和下载操作的缓存的键，以及拼接沙盒缓存的路径字符串。 图片缓存（字典）：存放于内存中；键为图片的URL，值为UIImage对象。作用：读取速度快，直接使用UIImage对象。 下载操作缓存（字典）：存放与内存中，键为图片的URL，值为NSBlockOperation对象。作用：用来避免对于同一张图片还要开启多个下载线程。 沙盒缓存(文件路径对应NSData)：存放于磁盘中，位于Cache文件夹内，路径为“Cache/图片URL的最后的部分”，值为NSData对象（将UIImage转化为NSData才能写入磁盘里）。作用：程序断网，再次启动也可以直接在磁盘中拿到图片。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//先去查看内存缓存中该图片时候已经存在,如果存在那么久直接拿来用,否则去检查磁盘缓存//如果有磁盘缓存,那么保存一份到内存,设置图片,否则就直接下载//1)没有下载过//2)重新打开程序UIImage *image = [self.images objectForKey:appM.icon];if (image) &#123;cell.imageView.image = image;NSLog(@&quot;%zd处的图片使用了内存缓存中的图片&quot;,indexPath.row) ;&#125;else&#123;//保存图片到沙盒缓存NSString *caches = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];//获得图片的名称,不能包含/NSString *fileName = [appM.icon lastPathComponent];//拼接图片的全路径NSString *fullPath = [caches stringByAppendingPathComponent:fileName];//检查磁盘缓存NSData *imageData = [NSData dataWithContentsOfFile:fullPath];//废除imageData = nil;if (imageData) &#123;UIImage *image = [UIImage imageWithData:imageData];cell.imageView.image = image;NSLog(@&quot;%zd处的图片使用了磁盘缓存中的图片&quot;,indexPath.row) ;//把图片保存到内存缓存[self.images setObject:image forKey:appM.icon];// NSLog(@&quot;%@&quot;,fullPath);&#125;else&#123;//检查该图片时候正在下载,如果是那么久什么都捕捉,否则再添加下载任务NSBlockOperation *download = [self.operations objectForKey:appM.icon];if (download) &#123;&#125;else&#123;//先清空cell原来的图片cell.imageView.image = [UIImage imageNamed:@&quot;Snip20160221_306&quot;];download = [NSBlockOperation blockOperationWithBlock:^&#123;NSURL *url = [NSURL URLWithString:appM.icon];NSData *imageData = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:imageData];NSLog(@&quot;%zd--下载---&quot;,indexPath.row);//容错处理if (image == nil) &#123;[self.operations removeObjectForKey:appM.icon];return ;&#125;//演示网速慢的情况//[NSThread sleepForTimeInterval:3.0];//把图片保存到内存缓存[self.images setObject:image forKey:appM.icon];//NSLog(@&quot;Download---%@&quot;,[NSThread currentThread]);//线程间通信[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;//cell.imageView.image = image;//刷新一行[self.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationLeft];//NSLog(@&quot;UI---%@&quot;,[NSThread currentThread]);&#125;];//写数据到沙盒[imageData writeToFile:fullPath atomically:YES];//移除图片的下载操作[self.operations removeObjectForKey:appM.icon];&#125;];//添加操作到操作缓存中[self.operations setObject:download forKey:appM.icon];//添加操作到队列中[self.queue addOperation:download];&#125; &#125;&#125;//3.返回cellreturn cell; 4.内存警告处理1234567-(void)didReceiveMemoryWarning&#123;[self.images removeAllObjects];//取消队列中所有的操作[self.queue cancelAllOperations];&#125;","categories":[],"tags":[],"keywords":[]},{"title":"iOS-多线程","slug":"iOS-多线程","date":"2019-02-18T14:03:07.000Z","updated":"2019-04-30T06:07:55.401Z","comments":true,"path":"2019/02/18/iOS-多线程/","link":"","permalink":"http://yoursite.com/2019/02/18/iOS-多线程/","excerpt":"","text":"进程进程是指在系统中运行的一个程序 线程 1个进程要想执行任务必须得有线程(每个进程至少要有1条线程) 线程的串行一个线程中任务的执行时串行的,如果要在1个线程中执行多个任务,那么只能一个一个地按顺序执行这些任务.也就是说,在同一时间内,1个线程只能执行1个任务 进程和线程的比较1.线程是CPU调用(执行任务)的最小单位 2.进程是CPU分配资源和调度的单位 3.一个程序可以对应多个线程,一个进程中可以有多个线程,但至少要有一个线程 4.同一个进程内的线程共享进程的资源 多线程1个进程中可以开启多个线程每条线程可以并行(同时)执行不同的任务,多线程技术可以提高程序的执行效率 多线程原理同一时间,CPU只能处理1条线程,只有1条线程在工作(执行) 多线程并发(同时)执行,其实CPU快速地在多条线程之间调度(切换) 如果CPU调度线程的时间足够快,就造成了多线程并发执行的假象 注:单核CPU 多线程优缺点优点:能适当提高程序的执行效率 能适当提高资源利用(CPU 内存利用率) 缺点:创建线程是有开销的,iOS下主要成本包括:内核数据结构(大约1KB),栈控件(子线程512KB,主线程1M,也可以使用-setStackSize:设置,但必须是4K的倍数,而且最小是16K),创建线程大约需要90毫秒的创建时间 如果开启大量的线程,会降低程序的性能 线程越多,CPU在调度线程上的开销就越大 程序设计更加复杂:比如线程之间的通信,多线程的数据共享 主线程一个iOS程序运行后,默认会开启1条线程,称为”主线程”或”UI线程” 主线程的主要作用:1.显示\\刷新UI界面 2.处理UI事件(比如点击事件,滚动事件,拖拽事件等) ###主线程的使用注意:### 1.别将比较耗时的操作放到主线程(文件上传下载,多次循环) 2.耗时操作会卡主主线程,严重影响到UI的流畅度,给用户一种”卡”的怀体验 ###获取主线程、当前线程###12345678910111213141516//1.获取主线程NSThread *mainThread = [NSThread mainThread];NSLog(@&quot;%@&quot;,mainThread);//2.获取当前线程NSThread *currentThread = [NSThread currentThread];NSLog(@&quot;%@&quot;,currentThread);//3.判断主线程// 3.1 number == 1// 3.2 类方法BOOL isMainThreadA = [NSThread mainThread];// 3.3 对象方法BOOL isMainThreadB = [currentThread isMainThread];NSLog(@&quot;%zd----%zd&quot;,isMainThreadA,isMainThreadB); 1.Pthread的简单使用（了解）pthread是一套通用的多线程API适用于Unix、Linux、Windows等系统跨平台、可移植、使用难度大C语言、需要手动管理线程生命周期1234567891011121314151617181920- (void)viewDidLoad &#123;[super viewDidLoad];//1.创建线程对象pthread_t thread;//2.创建线程/*第一个参数:线程对象 传递地址第二个参数:线程的属性 NULL第三个参数:指向函数的指针第四个参数:函数需要接受的参数*/pthread_create(&amp;thread, NULL, task, NULL);&#125;void *task(void *param)&#123;NSLog(@&quot;%@-----&quot;,[NSThread currentThread]);return NULL;&#125; ##2.NSthread的基本使用##NSthread使用更加面向对象简单易用，可直接操作线程对象OC语言、需要手动管理线程生命周期 ####NSThread创建的第一种方法####需要手动启用线程1234567891011121314151617181920- (void)viewDidLoad &#123;[super viewDidLoad];//1.创建线程/*第一个参数:目标对象,self第二个参数:方法选择器,调用方法第三个参数:前面调用方法需要传递的参数 nil*/NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run:) object:@&quot;ABC&quot;];//2.启动线程[thread start];&#125;-(void)run:(NSString *)param&#123;NSLog(@&quot;----RUN----%@&quot;,[NSThread currentThread]);&#125; NSThread创建的第二种方法分离子线程，自动启动线程1234567891011- (void)viewDidLoad &#123;[super viewDidLoad];[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@&quot;分离子线程&quot;];&#125;-(void)run:(NSString *)param&#123;NSLog(@&quot;----RUN----%@&quot;,[NSThread currentThread]);&#125; NSThread创建的第三种方法开启一条后台线程1234567891011- (void)viewDidLoad &#123;[super viewDidLoad];[self performSelectorInBackground:@selector(run:) withObject:@&quot;开启后台线程&quot;];&#125;-(void)run:(NSString *)param&#123;NSLog(@&quot;----RUN----%@&quot;,[NSThread currentThread]);&#125; 第二、三种方法的优缺点：优点：简单快捷缺点：无法对线程进行更详细的设置 #####NSThread需要注意的属性方法#####123456789//设置线程名称@property (nullable, copy) NSString *name //设置线程优先级+ (double)threadPriority;//获得主线程+（NSThread *)mainThread;//是否为主线程-（BOOL）isMainThread; NSThread线程生命周期线程的生命周期：当任务执行完毕后被释放 NSThread线程状态(了解)12NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];[thread start]; 启动线程12- (void)start; // 进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态 阻塞（暂停）线程123+ (void)sleepUntilDate:(NSDate *)date;+ (void)sleepForTimeInterval:(NSTimeInterval)ti;// 进入阻塞状态 强制停止线程12+ (void)exit;// 进入死亡状态 注意：一旦线程停止（死亡）了，就不能再次开启任务 多线程的安全隐患以售票员买票为例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import &quot;ViewController.h&quot;@interface ViewController ()//售票员 A B C@property (nonatomic,strong) NSThread *threadA;@property (nonatomic,strong) NSThread *threadB;@property (nonatomic,strong) NSThread *threadC;//总票数@property (nonatomic,assign) NSInteger totalCount;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];self.totalCount = 100;self.threadA = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicket) object:nil];self.threadB = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicket) object:nil];self.threadC = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicket) object:nil];self.threadA.name = @&quot;售票员1&quot;;self.threadB.name = @&quot;售票员1&quot;;self.threadC.name = @&quot;售票员1&quot;;[self.threadA start];[self.threadB start];[self.threadC start];&#125;-(void)saleTicket&#123;while (1) &#123;//锁必须是全局唯一的//1.注意加锁的位置//2.注意枷锁的前提条件//3.注意枷锁是需要代价的,需要耗费性能//4.枷锁的结果:线程同步@synchronized(self)&#123;NSInteger count = self.totalCount;if (count &gt; 0) &#123;self.totalCount = count - 1;//卖出一张票NSLog(@&quot;%@卖出一张票,还剩%zd张票&quot;,[NSThread currentThread].name,self.totalCount);&#125;else&#123;NSLog(@&quot;票已售完,明天请早!&quot;);break;&#125;&#125;&#125;&#125;@end 互斥锁使用格式@synchronized(锁对象) { // 需要锁定的代码 }注意：锁定1份代码只用1把锁，用多把锁是无效的 互斥锁的优缺点优点：能有效防止因多线程抢夺资源造成的数据安全问题缺点：需要消耗大量的CPU资源 互斥锁的使用前提：多条线程抢夺同一块资源 相关专业术语：线程同步线程同步的意思是：多条线程在同一条线上执行（按顺序地执行任务）互斥锁，就是使用了线程同步技术 原子和非原子属性的选择nonatomic和atomic对比atomic：线程安全，需要消耗大量的资源nonatomic：非线程安全，适合内存小的移动设备 iOS开发的建议所有属性都声明为nonatomic尽量避免多线程抢夺同一块资源尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力 NSThread实现线程间通信什么叫做线程间通信？ 在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常- 进行通信 线程间通信的体现 1个线程传递数据给另1个线程 在1个线程中执行完特定任务后，转到另1个线程继续执行任务 线程间通信常用方法123- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait; 线程间通信示例 – 图片下载 1234567891011121314151617181920212223242526272829-(void)touchesBegan:(nonnull NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event&#123;// [self download2];//开启一条子线程来下载图片[NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];&#125;-(void)downloadImage&#123;//1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源NSURL *url = [NSURL URLWithString:@&quot;http://p6.qhimg.com/t01d2954e2799c461ab.jpg&quot;];//2.根据url地址下载图片数据到本地（二进制数据NSData *data = [NSData dataWithContentsOfURL:url];//3.把下载到本地的二进制数据转换成图片UIImage *image = [UIImage imageWithData:data];//4.回到主线程刷新UI//4.1 第一种方式// [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES];//4.2 第二种方式// [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES];//4.3 第三种方式[self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES];&#125; 如何计算代码段的执行时间12345678910111213//第一种方法NSDate *start = [NSDate date];//2.根据url地址下载图片数据到本地（二进制数据）NSData *data = [NSData dataWithContentsOfURL:url];NSDate *end = [NSDate date];NSLog(@&quot;第二步操作花费的时间为%f&quot;,[end timeIntervalSinceDate:start]);//第二种方法CFTimeInterval start = CFAbsoluteTimeGetCurrent();NSData *data = [NSData dataWithContentsOfURL:url];CFTimeInterval end = CFAbsoluteTimeGetCurrent();NSLog(@&quot;第二步操作花费的时间为%f&quot;,end - start); 3.GCD的使用什么是GCD? 全称是Grand Central Dispatch，可译为“牛逼的中枢调度器” 纯C语言，提供了非常多强大的函数 GCD的优势 GCD是苹果公司为多核的并行运算提出的解决方案 GCD会自动利用更多的CPU内核（比如双核、四核） GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程） 程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码 GCD中有2个核心概念 任务：执行什么操作 队列：用来存放任务 GCD的使用就2个步骤 定制任务确定想做的事情 将任务添加到队列中GCD会自动将队列中的任务取出，放到对应的线程中执行任务的取出遵循队列的FIFO原则：先进先出，后进后出 执行任务GCD中有2个用来执行任务的常用函数1.用同步的方式执行任务123dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);queue：队列block：任务 2.用异步的方式执行任务1dispatch_async(dispatch_queue_t queue, dispatch_block_t block); 同步和异步的区别 同步：只能在当前线程中执行任务，不具备开启新线程的能力 异步：可以在新的线程中执行任务，具备开启新线程的能力 GCD中还有个用来执行任务的函数（栅栏函数)：1dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block); 在前面的任务执行结束后它才执行，而且它后面的任务等它执行完成之后才会执行- 这个queue不能是全局的并发队列 队列的类型 GCD的队列可以分为2大类型 并发队列（Concurrent Dispatch Queue）可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）并发功能只有在异步（dispatch_async）函数下才有效 串行队列（Serial Dispatch Queue）让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务） 容易混淆的术语有4个术语比较容易混淆：_同步_、_异步_、_并发_、_串行_同步和异步主要影响：能不能开启新的线程同步：只是在_当前_线程中执行任务，不具备开启新线程的能力异步：可以在_新的_线程中执行任务，_具备_开启新线程的能力 并发和串行主要影响：任务的执行方式并发：允许_多个_任务并发（同时）执行_串行_：_一个_任务执行完毕后，再执行下一个任务 并发队列 使用dispatch_queue_create函数创建队列 123dispatch_queue_tdispatch_queue_create(const char *label, // 队列名称 dispatch_queue_attr_t attr); // 队列的类型 创建并发队列 1dispatch_queue_t queue = dispatch_queue_create(&quot;com.520it.queue&quot;, DISPATCH_QUEUE_CONCURRENT); GCD默认已经提供了全局的并发队列，供整个应用使用，可以无需手动创建使用dispatch_get_global_queue函数获得全局的并发队列 123dispatch_queue_t dispatch_get_global_queue(dispatch_queue_priority_t priority, // 队列的优先级unsigned long flags); // 此参数暂时无用，用0即可 获得全局并发队列 1dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 全局并发队列的优先级 1234#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台 串行队列 GCD中获得串行有2种途径使用dispatch_queue_create函数创建串行队列12// 创建串行队列（队列类型传递NULL或者DISPATCH_QUEUE_SERIAL）dispatch_queue_t queue = dispatch_queue_create(&quot;com.520it.queue&quot;, NULL); 使用主队列（跟主线程相关联的队列）1.主队列是GCD自带的一种特殊的串行队列2.放在主队列中的任务，都会放到主线程中执行3.使用dispatch_get_main_queue()获得主队列1dispatch_queue_t queue = dispatch_get_main_queue(); 各种队列的执行效果 GCD线程间通信 从子线程回到主线程1234567dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;// 执行耗时的异步操作...dispatch_async(dispatch_get_main_queue(), ^&#123;// 回到主线程，执行UI刷新操作&#125;);&#125;); 延时执行iOS常见的延时执行 1.调用NSObject的方法 12[self performSelector:@selector(run) withObject:nil afterDelay:2.0];// 2秒后再调用self的run方法 2.使用GCD函数 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;// 2秒后执行这里的代码...&#125;); 3.使用NSTimer 1[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:NO]; 一次性代码 使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次 不可以放在懒加载中执行1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;// 只执行1次的代码(这里面默认是线程安全的)&#125;); 快速迭代 使用dispatch_apply函数能进行快速迭代遍历123456//第一个参数：遍历的次数//第二个参数：队列(并发队列)，不可以传主队列会造成死锁；不可以传串行队列，没有任何作用//第三个参数：index 索引dispatch_apply(10, dispatch_get_global_queue(0, 0), ^(size_t index)&#123;// 执行10次代码，index顺序不确定&#125;); 队列组 有这么1种需求1.分别异步执行2个耗时的操作2.等2个异步操作都执行完毕后，再回到主线程执行操作 如果想要快速高效地实现上述需求，可以考虑用队列组1234567891011121314dispatch_group_t group = dispatch_group_create();//1.封装任务//2.把任务添加到队列中//3.会监听任务的执行情况，通知groupdispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;// 执行1个耗时的异步操作&#125;);dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;// 执行1个耗时的异步操作&#125;);//拦截通知，当队列组中所有的任务都执行完毕的时候会进入到下面的方法dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;// 等前面的异步操作都执行完毕后，回到主线程...&#125;); 3.NSOperation的使用 NSOperation的作用配合使用NSOperation和NSOperationQueue也能实现多线程编程 NSOperation和NSOperationQueue实现多线程的具体步骤1.先将需要执行的操作封装到一个NSOperation对象中2.然后将NSOperation对象添加到NSOperationQueue中3.系统会自动将NSOperationQueue中的NSOperation取出来4.将取出的NSOperation封装的操作放到一条新线程中执行 #####NSOperation的子类##### NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类 使用NSOperation子类的方式有3种1.NSInvocationOperation2.NSBlockOperation3.自定义子类继承NSOperation，实现内部相应的方法 NSInvocationOperation 创建NSInvocationOperation对象 12345- (id)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;调用start方法开始执行操作- (void)start;一旦执行操作，就会调用target的sel方法 注意1.默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作2.只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作 #####NSBlockOperation##### 创建NSBlockOperation对象 1+ (id)blockOperationWithBlock:(void (^)(void))block; 通过addExecutionBlock:方法添加更多的操作 1- (void)addExecutionBlock:(void (^)(void))block; 注意：只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作 NSOperationQueue NSOperationQueue的作用1.NSOperation可以调用start方法来执行任务，但默认是同步执行的2.如果将NSOperation添加到NSOperationQueue（操作队列）中，系统会自动异步执行NSOperation中的操作 添加操作到NSOperationQueue中 12- (void)addOperation:(NSOperation *)op;- (void)addOperationWithBlock:(void (^)(void))block; #####自定义NSOperation##### 自定义NSOperation的步骤很简单重写- (void)main方法，在里面实现想执行的任务 重写- (void)main方法的注意点自己创建自动释放池（因为如果是异步操作，无法访问主线程的自动释放池）经常通过- (BOOL)isCancelled方法检测操作是否被取消，对取消做出响应 最大并发数 什么是并发数同时执行的任务数比如，同时开3个线程执行3个任务，并发数就是3 最大并发数的相关方法 12345678- (NSInteger)maxConcurrentOperationCount;- (void)setMaxConcurrentOperationCount:(NSInteger)cnt;//串行执行任务不等于只开一条线程(编程同步)maxConcurrentOperationCount &gt; 1 并发队列maxConcurrentOperationCount == 1 串行队列maxConcurrentOperationCount == 0 不会执行任务maxConcurrentOperationCount == -1 特殊意义 最大值 表示不受限制 队列的取消、暂停、恢复 取消队列的所有操作 123//取消不可以恢复- (void)cancelAllOperations;//提示：也可以调用NSOperation的- (void)cancel方法取消单个操作 暂停和恢复队列 1234//暂停是可以恢复//不能暂停当前正在处于执行状态的任务- (void)setSuspended:(BOOL)b; // YES代表暂停队列，NO代表恢复队列- (BOOL)isSuspended; 操作依赖 NSOperation之间可以设置依赖来保证执行顺序比如一定要让操作A执行完后，才能执行操作B，可以这么写 1[operationB addDependency:operationA]; // 操作B依赖于操作A 可以在不同queue的NSOperation之间创建依赖关系 操作的监听 可以监听一个操作的执行完毕12- (void (^)(void))completionBlock;- (void)setCompletionBlock:(void (^)(void))block; NSOperation实现线程间通信12345678910111213141516171819202122232425262728-(void)download&#123;//http://s15.sinaimg.cn/bmiddle/4c0b78455061c1b7f1d0e//1.开子线程下载图片//1.1 非主队列NSOperationQueue *queue = [[NSOperationQueue alloc]init];//1.2 封装操作NSBlockOperation *download = [NSBlockOperation blockOperationWithBlock:^&#123;NSURL *url = [NSURL URLWithString:@&quot;http://s15.sinaimg.cn/bmiddle/4c0b78455061c1b7f1d0e&quot;];NSData *imageData = [NSData dataWithContentsOfURL:url];UIImage *image = [UIImage imageWithData:imageData];NSLog(@&quot;download---%@&quot;,[NSThread currentThread]);//3.回到主线程、更新UI[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;self.imageView.image = image;NSLog(@&quot;UI---%@&quot;,[NSThread currentThread]);&#125;];&#125;];//2.添加操作到队列[queue addOperation:download];&#125;","categories":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}],"keywords":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/categories/Objective-C/"}]}]}