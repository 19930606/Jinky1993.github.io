<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="小金渣blog">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->

    <meta name="keywords" content="进阶">


    <meta name="description" content="
基础知识1.设计模式是什么？ 你知道哪些设计模式，并简要叙述？设计模式是一种编码经验，用比较成熟的逻辑去处理某一类型的事情

MVC模式：Model View Control，把模型、视图、控...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>面试题知识点梳理 | 小金渣blog</title>


    <link rel="alternate" href="/atom.xml" title="小金渣blog" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="小金渣">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 拒绝三次握手，有事说事。 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">小金渣blog</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Objective-C/"><i class="fa "></i>Objective-C</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/Swift/"><i class="fa "></i>Swift</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/进阶/"><i class="fa "></i>进阶</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="面试题知识点梳理">
            
	            面试题知识点梳理
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/进阶/">进阶</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/进阶/">进阶</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/05/06</span>
        </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <p><img src="/2019/05/06/面试题知识点梳理/timg_gaitubao_720x251.png" alt></p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h3 id="1-设计模式是什么？-你知道哪些设计模式，并简要叙述？"><a href="#1-设计模式是什么？-你知道哪些设计模式，并简要叙述？" class="headerlink" title="1.设计模式是什么？ 你知道哪些设计模式，并简要叙述？"></a>1.设计模式是什么？ 你知道哪些设计模式，并简要叙述？</h3><p>设计模式是一种编码经验，用比较成熟的逻辑去处理某一类型的事情</p>
<ul>
<li>MVC模式：Model View Control，把模型、视图、控制器层进行解耦合编写</li>
<li>MVVM模式：Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写</li>
<li>单例模式：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次</li>
<li>观察者模式：KVO是典型的观察者模式，观察某个属性的状态，状态发生变化时通知观察者</li>
<li>委托模式：代理+协议的组合。实现1对1的反向传值操作</li>
<li>工厂模式：通过一个类方法，批量的根据已有模板生产对象</li>
</ul>
<hr>
<h3 id="2-MVC-和-MVVM-的区别"><a href="#2-MVC-和-MVVM-的区别" class="headerlink" title="2.MVC 和 MVVM 的区别"></a>2.MVC 和 MVVM 的区别</h3><p><strong>MVC模式</strong>（Model-View-Controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。<br><img src="/2019/05/06/面试题知识点梳理/MVC.png" alt="MVC"></p>
<ul>
<li>视图层（View），是直接面向最终用户的。它是提供给用户的操作界面，是程序的外壳</li>
<li>数据层（Model），是核心的，也就是程序需要操作的数据或信息</li>
<li>控制层（Controller），它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果</li>
</ul>
<p>三个模块之间都是可以通信的，不过都是单向通信。</p>
<ul>
<li>1.View 传送指令到 Controller</li>
<li>2.Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>3.Model 将新的数据发送到 View，用户得到反馈</li>
</ul>
<hr>
<p><strong>MVP模式</strong>(Model-View-Presenter)<br><img src="/2019/05/06/面试题知识点梳理/MVP.png" alt="MVP"><br>模块间的通信是相互的，但View和Model之间的通信是绝对禁止的。</p>
<ul>
<li>1.Presenter（英文中翻译是：主持人，主办方），View和Model之间的通信必须是通过Presenter来进行传达的</li>
<li>2.所有的业务逻辑都是放在Presenter中（这样会显的比较臃肿，具体设计时，要注意对它进行“瘦身”）</li>
<li>3.View只是负责展示数据就行了（没有主动性），由Presenter决定去Model中拿什么样的数据</li>
</ul>
<hr>
<p><strong>MVVM模式</strong>(Model-View-ViewModel)<br><img src="/2019/05/06/面试题知识点梳理/MVVM.png" alt="MVVM"></p>
<ul>
<li>1.MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</li>
<li>2.唯一的区别就是，View和ViewModel之间是“双向绑定“的，View的变动，自动反映在 ViewModel，反之亦然。</li>
<li>3.MVVM可以降低UI显示与后端逻辑代码的耦合度，即更换界面时，只需要修改很少的逻辑代码就可以实现，甚至不用修改。</li>
</ul>
<hr>
<p>MVVM是对胖模型进行的拆分，其本质是给控制器减负，将一些弱业务逻辑放到VM中去处理。 MVC是一切设计的基础，所有新的设计模式都是基于MVC进行的改进</p>
<hr>
<h3 id="3-import跟-include-有什么区别，-class呢，-import-lt-gt-跟-import””有什么区别？"><a href="#3-import跟-include-有什么区别，-class呢，-import-lt-gt-跟-import””有什么区别？" class="headerlink" title="3.#import跟 #include 有什么区别，@class呢，#import&lt;&gt; 跟 #import””有什么区别？"></a>3.#import跟 #include 有什么区别，@class呢，#import&lt;&gt; 跟 #import””有什么区别？</h3><ul>
<li>#import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动只导入一次，不会重复导入</li>
<li>@class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含</li>
<li>#import&lt;&gt;用来包含系统的头文件，#import””用来包含用户头文件</li>
</ul>
<hr>
<h3 id="4-frame-和-bounds-有什么不同？"><a href="#4-frame-和-bounds-有什么不同？" class="headerlink" title="4.frame 和 bounds 有什么不同？"></a>4.frame 和 bounds 有什么不同？</h3><ul>
<li>frame指的是：该view在父view坐标系统中的位置和大小。(参照点是父view的坐标系统) </li>
<li>bounds指的是：该view在本身坐标系统中的位置和大小。(参照点是本身坐标系统)</li>
</ul>
<hr>
<h3 id="5-Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方法用继承好还是分类好？为什么？"><a href="#5-Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方法用继承好还是分类好？为什么？" class="headerlink" title="5.Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方法用继承好还是分类好？为什么？"></a>5.Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方法用继承好还是分类好？为什么？</h3><ul>
<li>Objective-C的类不可以多重继承，可以实现多个接口（协议）</li>
<li>Category是类别</li>
<li>一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系</li>
</ul>
<hr>
<h3 id="6-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><a href="#6-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的" class="headerlink" title="6.@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的"></a>6.@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</h3><ul>
<li>@property 的本质是什么？ @property = ivar + getter + setter;</li>
<li>“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法） “属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据</li>
<li>Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。</li>
</ul>
<hr>
<h3 id="7-property中有哪些属性关键字？-property-后面可以有哪些修饰符？"><a href="#7-property中有哪些属性关键字？-property-后面可以有哪些修饰符？" class="headerlink" title="7.@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？"></a>7.@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</h3><p>属性可以拥有的特质分为四类:</p>
<ul>
<li>1.原子性— nonatomic 特质</li>
<li>2.读/写权限—readwrite(读写)、readonly (只读) </li>
<li>3.内存管理语义—assign、strong、 weak、unsafe_unretained、copy </li>
<li>4.方法名—getter= 、setter= 5.不常用的：nonnull,null_resettable,nullable</li>
</ul>
<hr>
<h3 id="8-属性关键字-readwrite，readonly，assign，retain，copy，nonatomic-各是什么作用，在那种情况下用？"><a href="#8-属性关键字-readwrite，readonly，assign，retain，copy，nonatomic-各是什么作用，在那种情况下用？" class="headerlink" title="8.属性关键字 readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用？"></a>8.属性关键字 readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用？</h3><ul>
<li>1.readwrite 是可读可写特性。需要生成getter方法和setter方法</li>
<li>2.readonly 是只读特性。只会生成getter方法，不会生成setter方法，不希望属性在类外改变</li>
<li>3.assign 是赋值特性。setter方法将传入参数赋值给实例变量;仅设置变量时,assign用于基本数据类型</li>
<li>4.retain(MRC)/strong(ARC) 表示持有特性。setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1</li>
<li>5.copy 表示拷贝特性。setter方法将传入对象复制一份，需要完全一份新的变量时</li>
<li>nonatomic 非原子操作。不写的话默认就是atomic。atomic 和 nonatomic 的区别在于，系统自动生成的 getter/setter 方法不一样。对于atomic的属性，系统生成的 getter/setter 会保证 get、set 操作的完整性，而nonatomic就没有这个保证了。所以，nonatomic的速度要比atomic快。<br>不过atomic可并不能保证线程安全</li>
</ul>
<hr>
<h3 id="9-什么情况使用-weak-关键字，相比-assign-有什么不同？"><a href="#9-什么情况使用-weak-关键字，相比-assign-有什么不同？" class="headerlink" title="9.什么情况使用 weak 关键字，相比 assign 有什么不同？"></a>9.什么情况使用 weak 关键字，相比 assign 有什么不同？</h3><ul>
<li>1.在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性</li>
<li><p>2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。</p>
<p>IBOutlet连出来的视图属性为什么可以被设置成weak?<br>因为父控件的subViews数组已经对它有一个强引用</p>
<ul>
<li>不同点： assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。 weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)</li>
</ul>
<hr>
<h3 id="10-怎么用-copy-关键字？"><a href="#10-怎么用-copy-关键字？" class="headerlink" title="10.怎么用 copy 关键字？"></a>10.怎么用 copy 关键字？</h3><p><strong>用途</strong></p>
<ul>
<li>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary</li>
<li>block 也经常使用 copy 关键字</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。</li>
</ul>
<hr>
<h3 id="11-用-property声明的-NSString-NSArray-NSDictionary-经常使用-copy-关键字，为什么？如果改用strong关键字，可能造成什么问题？"><a href="#11-用-property声明的-NSString-NSArray-NSDictionary-经常使用-copy-关键字，为什么？如果改用strong关键字，可能造成什么问题？" class="headerlink" title="11.用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？"></a>11.用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3><p><strong>答：</strong> 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
<ul>
<li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本</li>
<li>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性</li>
</ul>
<p><strong>总结：</strong> 使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值</p>
<hr>
<h3 id="12-浅拷贝和深拷贝的区别？"><a href="#12-浅拷贝和深拷贝的区别？" class="headerlink" title="12.浅拷贝和深拷贝的区别？"></a>12.浅拷贝和深拷贝的区别？</h3><ul>
<li>浅拷贝：只复制指向对象的指针，而不复制引用对象本身</li>
<li>深拷贝：复制引用对象本身。内存中存在了两份独立对象本身，当修改A时，A_copy不变</li>
</ul>
<hr>
<h3 id="13-这个写法会出什么问题：-property-nonatomic-copy-NSMutableArray-arr"><a href="#13-这个写法会出什么问题：-property-nonatomic-copy-NSMutableArray-arr" class="headerlink" title="13.这个写法会出什么问题：@property  (nonatomic, copy)  NSMutableArray  *arr;"></a>13.这个写法会出什么问题：@property  (nonatomic, copy)  NSMutableArray  *arr;</h3><p><strong>问题：</strong> 添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃。<br><strong>例如：</strong>  -[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460<br>// copy后返回的是不可变对象（即 arr 是 NSArray 类型，NSArray 类型对象不能调用 NSMutableArray 类型对象的方法）<br><strong>原因：</strong> 是因为 copy 就是复制一个不可变 NSArray 的对象，不能对 NSArray 对象进行添加/修改。</p>
<hr>
</li>
</ul>
<h3 id="14-如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"><a href="#14-如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？" class="headerlink" title="14.如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？"></a>14.如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</h3><ul>
<li>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。</li>
<li>具体步骤</li>
</ul>
<ol>
<li>需声明该类遵从 NSCopying 协议</li>
<li>实现 NSCopying 协议的方法</li>
<li>该协议只有一个方法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> -(id)copyWithZone:(NSZone *)zone; // 注意：使用 copy 修饰符，调用的是copy方法，其实真正需要实现的是 “copyWithZone” 方法。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="15-synthesize-和-dynamic-分别有什么作用？"><a href="#15-synthesize-和-dynamic-分别有什么作用？" class="headerlink" title="15.@synthesize 和 @dynamic 分别有什么作用？"></a>15.@synthesize 和 @dynamic 分别有什么作用？</h3><ul>
<li>@property有两个对应的词，一个是@synthesize（合成实例变量），一个是@dynamic</li>
<li>如果@synthesize和@dynamic都没有写，那么默认的就是 @synthesize var = _var; 在类的实现代码里通过 @synthesize 语法可以来指定实例变量的名字。(@synthesize var = _newVar;) </li>
<li>@synthesize 的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法</li>
<li>@dynamic 告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成（如，@dynamic var）</li>
</ul>
<hr>
<h3 id="16-常见的-Objective-C-的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int"><a href="#16-常见的-Objective-C-的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int" class="headerlink" title="16.常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int"></a>16.常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int</h3><ul>
<li>Objective-C的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象</li>
<li>C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值</li>
<li>NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是long。</li>
</ul>
<hr>
<h3 id="17-id-声明的对象有什么特性？"><a href="#17-id-声明的对象有什么特性？" class="headerlink" title="17.id 声明的对象有什么特性？"></a>17.id 声明的对象有什么特性？</h3><ul>
<li>id 声明的对象具有运行时的特性，即可以指向任意类型的Objcetive-C的对象。</li>
</ul>
<hr>
<h3 id="18-Objective-C-如何对内存管理的，说说你的看法和解决方法？"><a href="#18-Objective-C-如何对内存管理的，说说你的看法和解决方法？" class="headerlink" title="18.Objective-C 如何对内存管理的，说说你的看法和解决方法？"></a>18.Objective-C 如何对内存管理的，说说你的看法和解决方法？</h3><p> <strong>答：</strong> Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。</p>
<ul>
<li>自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码</li>
<li>手动内存计数MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则</li>
<li>内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响</li>
</ul>
<hr>
<h3 id="19-Objective-C-中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？"><a href="#19-Objective-C-中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？" class="headerlink" title="19.Objective-C 中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？"></a>19.Objective-C 中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？</h3><p><strong>线程创建有三种方法：</strong></p>
<ul>
<li>使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue</li>
<li>在主线程执行代码，方法是performSelectorOnMainThread</li>
<li>延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:</li>
</ul>
<hr>
<h3 id="20-Category（类别）、-Extension（扩展）和继承的区别？"><a href="#20-Category（类别）、-Extension（扩展）和继承的区别？" class="headerlink" title="20.Category（类别）、 Extension（扩展）和继承的区别？"></a>20.Category（类别）、 Extension（扩展）和继承的区别？</h3><p><strong>区别：</strong></p>
<ul>
<li><ol>
<li>分类有名字，类扩展没有分类名字，是一种特殊的分类</li>
</ol>
</li>
<li><ol start="2">
<li>分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法</li>
</ol>
</li>
<li><ol start="3">
<li>继承可以增加，修改或者删除方法，并且可以增加属性</li>
</ol>
</li>
</ul>
<hr>
<h3 id="21-我们说的OC是动态运行时语言是什么意思？"><a href="#21-我们说的OC是动态运行时语言是什么意思？" class="headerlink" title="21.我们说的OC是动态运行时语言是什么意思？"></a>21.我们说的OC是动态运行时语言是什么意思？</h3><p><strong>答：</strong> 主要是将数据类型的确定由编译时，推迟到了运行时。简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法</p>
<hr>
<h3 id="22-为什么我们常见的delegate属性都用是week而不是retain-strong？"><a href="#22-为什么我们常见的delegate属性都用是week而不是retain-strong？" class="headerlink" title="22.为什么我们常见的delegate属性都用是week而不是retain/strong？"></a>22.为什么我们常见的delegate属性都用是week而不是retain/strong？</h3><p><strong>答：</strong> 是为了防止delegate两端产生不必要的循环引用。 @property (nonatomic, weak) id delegate;</p>
<hr>
<h3 id="23-什么时候用delete，什么时候用Notification？"><a href="#23-什么时候用delete，什么时候用Notification？" class="headerlink" title="23.什么时候用delete，什么时候用Notification？"></a>23.什么时候用delete，什么时候用Notification？</h3><ul>
<li>Delegate(委托模式)：1对1的反向消息通知功能</li>
<li>Notification(通知模式)：只想要把消息发送出去，告知某些状态的变化。但是并不关心谁想要知道这个</li>
</ul>
<hr>
<h3 id="24-什么是-KVO-和-KVC？"><a href="#24-什么是-KVO-和-KVC？" class="headerlink" title="24.什么是 KVO 和 KVC？"></a>24.什么是 KVO 和 KVC？</h3><p><strong>KVC</strong>(Key-Value-Coding): 键值编码 是一种通过字符串间接访问对象的方式（即给属性赋值）</p>
<p><strong>KVO</strong>(key-Value-Observing)：键值观察机制 他提供了观察某一属性变化的方法，极大的简化了代码；KVO只能被KVC触发，包括使用setValue:forKey:方法和点语法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 通过下方方法为属性添加KVO观察</span><br><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br><span class="line"></span><br><span class="line">// 当被观察的属性发送变化时，会自动触发下方方法</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意:</strong> KVC 和 KVO 的 keyPath 可以是属性、实例变量、成员变量。</p>
<hr>
<h3 id="25-KVC的底层实现？"><a href="#25-KVC的底层实现？" class="headerlink" title="25.KVC的底层实现？"></a>25.KVC的底层实现？</h3><p><strong>当一个对象调用setValue方法时，方法内部会做以下操作：</strong> </p>
<ul>
<li>1.检查是否存在相应的key的set方法，如果存在，就调用set方法。</li>
<li>2.如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值</li>
<li>3.如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值</li>
<li>4.如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法</li>
</ul>
<p><strong>这些方法的默认实现都是抛出异常，我们可以根据需要重写它们</strong></p>
<hr>
<h3 id="26-KVO的底层实现？"><a href="#26-KVO的底层实现？" class="headerlink" title="26.KVO的底层实现？"></a>26.KVO的底层实现？</h3><ul>
<li>KVO基于runtime机制实现</li>
<li><a href="https://www.jianshu.com/p/829864680648" target="_blank" rel="noopener">探究KVO的底层实现原理</a></li>
</ul>
<hr>
<h3 id="27-ViewController生命周期"><a href="#27-ViewController生命周期" class="headerlink" title="27.ViewController生命周期"></a>27.ViewController生命周期</h3><p><strong>按照执行顺序排列：</strong></p>
<ul>
<li>initWithCoder：通过nib文件初始化时触发</li>
<li>awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象</li>
<li>loadView：开始加载视图控制器自带的view</li>
<li>viewDidLoad：视图控制器的view被加载完成</li>
<li>viewWillAppear：视图控制器的view将要显示在window上</li>
<li>updateViewConstraints：视图控制器的view开始更新AutoLayout约束</li>
<li>viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置</li>
<li>viewDidLayoutSubviews：视图控制器的view已经更新视图的位置</li>
<li>viewDidAppear：视图控制器的view已经展示到window上</li>
<li>viewWillDisappear：视图控制器的view将要从window上消失</li>
<li>viewDidDisappear：视图控制器的view已经从window上消失</li>
</ul>
<hr>
<h3 id="28-方法和选择器有何不同？"><a href="#28-方法和选择器有何不同？" class="headerlink" title="28.方法和选择器有何不同？"></a>28.方法和选择器有何不同？</h3><ul>
<li>selector是一个方法的名字，方法是一个组合体，包含了名字和实现</li>
</ul>
<hr>
<h3 id="29-你是否接触过OC中的反射机制？简单聊一下概念和使用"><a href="#29-你是否接触过OC中的反射机制？简单聊一下概念和使用" class="headerlink" title="29.你是否接触过OC中的反射机制？简单聊一下概念和使用"></a>29.你是否接触过OC中的反射机制？简单聊一下概念和使用</h3><p><strong>class反射</strong></p>
<ul>
<li>通过类名的字符串形式实例化对象</li>
<li>Class class = NSClassFromString(@”student”);</li>
<li>Student *stu = [[class alloc] init];</li>
<li>将类名变为字符串</li>
<li>Class class =[Student class];</li>
<li>NSString *className = NSStringFromClass(class);</li>
</ul>
<p><strong>SEL的反射</strong></p>
<ul>
<li>通过方法的字符串形式实例化方法</li>
<li>SEL selector = NSSelectorFromString(@”setName”);</li>
<li>[stu performSelector:selector withObject:@”Jin”];</li>
<li>将方法变成字符串</li>
<li>NSStringFromSelector(@selector*(setName:));</li>
</ul>
<hr>
<h3 id="30-调用方法的两种方式？"><a href="#30-调用方法的两种方式？" class="headerlink" title="30.调用方法的两种方式？"></a>30.调用方法的两种方式？</h3><ul>
<li>直接通过方法名来调用。[person show];</li>
<li>间接的通过SEL数据来调用 。SEL aaa = @selector(show); [person performSelector:aaa];</li>
</ul>
<hr>
<h3 id="31-如何对iOS设备进行性能测试？"><a href="#31-如何对iOS设备进行性能测试？" class="headerlink" title="31.如何对iOS设备进行性能测试？"></a>31.如何对iOS设备进行性能测试？</h3><p><strong>答：</strong> Profile-&gt; Instruments -&gt;Time Profiler</p>
<hr>
<h3 id="32-开发项目时你是怎么检查内存泄露？"><a href="#32-开发项目时你是怎么检查内存泄露？" class="headerlink" title="32.开发项目时你是怎么检查内存泄露？"></a>32.开发项目时你是怎么检查内存泄露？</h3><ul>
<li>静态分析 analyze</li>
<li>instruments工具里面有个leak可以动态分析</li>
</ul>
<p>**</p>
<h3 id="32-什么是懒加载？"><a href="#32-什么是懒加载？" class="headerlink" title="32.什么是懒加载？"></a>32.什么是懒加载？</h3><p><strong>答：</strong> 懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。<br><strong>例：</strong> 最好也最简单的一个例子就是tableView中图片的加载显示了, 一个延时加载, 避免内存过高,一个异步加载,避免线程堵塞提高用户体验。</p>
<hr>
<h3 id="33-类变量的-public，-protected，-private，-package-声明各有什么含义？"><a href="#33-类变量的-public，-protected，-private，-package-声明各有什么含义？" class="headerlink" title="33.类变量的 @public，@protected，@private，@package 声明各有什么含义？"></a>33.类变量的 @public，@protected，@private，@package 声明各有什么含义？</h3><ul>
<li><strong>@public</strong>任何地方都能访问</li>
<li><strong>@protected</strong>该类和子类中访问,是默认的</li>
<li><strong>@private</strong>只能在本类中访问</li>
<li><strong>@package</strong>本包内使用,跨包不可以</li>
</ul>
<hr>
<h3 id="34-什么是谓词？"><a href="#34-什么是谓词？" class="headerlink" title="34.什么是谓词？"></a>34.什么是谓词？</h3><p><strong>谓词就是通过NSPredicate给定的逻辑条件作为约束条件,完成对数据的筛选</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义谓词对象,谓词对象中包含了过滤条件(过滤条件比较多)</span><br><span class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;age&lt;%d&quot;,30];</span><br><span class="line"></span><br><span class="line">//使用谓词条件过滤数组中的元素,过滤之后返回查询的结果</span><br><span class="line">NSArray *array = [persons filteredArrayUsingPredicate:predicate];</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="35-isa指针问题"><a href="#35-isa指针问题" class="headerlink" title="35.isa指针问题"></a>35.isa指针问题</h3><ul>
<li>isa：是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类,而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调 用时,先会从本身查找类方法的实现,如果没有,元类会向他父类查找该方法。同时注意的是:元类(meteClass)也是类,它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass)。根元类的isa指针指向本身,这样形成了一个封闭的内循环。</li>
</ul>
<hr>
<h3 id="36-如何访问并修改一个类的私有属性？"><a href="#36-如何访问并修改一个类的私有属性？" class="headerlink" title="36.如何访问并修改一个类的私有属性？"></a>36.如何访问并修改一个类的私有属性？</h3><ul>
<li>一种是通过KVC获取</li>
<li>通过runtime访问并修改私有属性</li>
</ul>
<hr>
<h3 id="37-一个objc对象的isa的指针指向什么？有什么作用？"><a href="#37-一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="37.一个objc对象的isa的指针指向什么？有什么作用？"></a>37.一个objc对象的isa的指针指向什么？有什么作用？</h3><p><strong>答：</strong> 指向他的类对象,从而可以找到对象上的方法</p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href target="_blank">小金渣</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
    
        <a href="/2019/04/26/Swift基础—集合类型/" class="next-post btn btn-default" title="Swift基础—集合类型">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Swift基础—集合类型</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'Yx8l3CPhdT6l91ghPbw3AFWY-gzGzoHsz',
            appKey: '9oIQV82CgBxpaAMJ2r9owrXi',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础知识"><span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-设计模式是什么？-你知道哪些设计模式，并简要叙述？"><span class="toc-text">1.设计模式是什么？ 你知道哪些设计模式，并简要叙述？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-MVC-和-MVVM-的区别"><span class="toc-text">2.MVC 和 MVVM 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-import跟-include-有什么区别，-class呢，-import-lt-gt-跟-import””有什么区别？"><span class="toc-text">3.#import跟 #include 有什么区别，@class呢，#import&lt;&gt; 跟 #import””有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-frame-和-bounds-有什么不同？"><span class="toc-text">4.frame 和 bounds 有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方法用继承好还是分类好？为什么？"><span class="toc-text">5.Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方法用继承好还是分类好？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-property-的本质是什么？ivar、getter、setter-是如何生成并添加到这个类中的"><span class="toc-text">6.@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-property中有哪些属性关键字？-property-后面可以有哪些修饰符？"><span class="toc-text">7.@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-属性关键字-readwrite，readonly，assign，retain，copy，nonatomic-各是什么作用，在那种情况下用？"><span class="toc-text">8.属性关键字 readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-什么情况使用-weak-关键字，相比-assign-有什么不同？"><span class="toc-text">9.什么情况使用 weak 关键字，相比 assign 有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-怎么用-copy-关键字？"><span class="toc-text">10.怎么用 copy 关键字？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-用-property声明的-NSString-NSArray-NSDictionary-经常使用-copy-关键字，为什么？如果改用strong关键字，可能造成什么问题？"><span class="toc-text">11.用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-浅拷贝和深拷贝的区别？"><span class="toc-text">12.浅拷贝和深拷贝的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-这个写法会出什么问题：-property-nonatomic-copy-NSMutableArray-arr"><span class="toc-text">13.这个写法会出什么问题：@property  (nonatomic, copy)  NSMutableArray  *arr;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-如何让自己的类用-copy-修饰符？如何重写带-copy-关键字的-setter？"><span class="toc-text">14.如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-synthesize-和-dynamic-分别有什么作用？"><span class="toc-text">15.@synthesize 和 @dynamic 分别有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-常见的-Objective-C-的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int"><span class="toc-text">16.常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-id-声明的对象有什么特性？"><span class="toc-text">17.id 声明的对象有什么特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-Objective-C-如何对内存管理的，说说你的看法和解决方法？"><span class="toc-text">18.Objective-C 如何对内存管理的，说说你的看法和解决方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Objective-C-中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？"><span class="toc-text">19.Objective-C 中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-Category（类别）、-Extension（扩展）和继承的区别？"><span class="toc-text">20.Category（类别）、 Extension（扩展）和继承的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-我们说的OC是动态运行时语言是什么意思？"><span class="toc-text">21.我们说的OC是动态运行时语言是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-为什么我们常见的delegate属性都用是week而不是retain-strong？"><span class="toc-text">22.为什么我们常见的delegate属性都用是week而不是retain/strong？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-什么时候用delete，什么时候用Notification？"><span class="toc-text">23.什么时候用delete，什么时候用Notification？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-什么是-KVO-和-KVC？"><span class="toc-text">24.什么是 KVO 和 KVC？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-KVC的底层实现？"><span class="toc-text">25.KVC的底层实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-KVO的底层实现？"><span class="toc-text">26.KVO的底层实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-ViewController生命周期"><span class="toc-text">27.ViewController生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-方法和选择器有何不同？"><span class="toc-text">28.方法和选择器有何不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-你是否接触过OC中的反射机制？简单聊一下概念和使用"><span class="toc-text">29.你是否接触过OC中的反射机制？简单聊一下概念和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-调用方法的两种方式？"><span class="toc-text">30.调用方法的两种方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-如何对iOS设备进行性能测试？"><span class="toc-text">31.如何对iOS设备进行性能测试？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-开发项目时你是怎么检查内存泄露？"><span class="toc-text">32.开发项目时你是怎么检查内存泄露？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-什么是懒加载？"><span class="toc-text">32.什么是懒加载？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-类变量的-public，-protected，-private，-package-声明各有什么含义？"><span class="toc-text">33.类变量的 @public，@protected，@private，@package 声明各有什么含义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-什么是谓词？"><span class="toc-text">34.什么是谓词？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-isa指针问题"><span class="toc-text">35.isa指针问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-如何访问并修改一个类的私有属性？"><span class="toc-text">36.如何访问并修改一个类的私有属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-一个objc对象的isa的指针指向什么？有什么作用？"><span class="toc-text">37.一个objc对象的isa的指针指向什么？有什么作用？</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>